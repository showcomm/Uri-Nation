<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Uri-Nation — Game Runner</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: #1a1a2e;
  color: #e0e0e0;
  height: 100vh;
  overflow: hidden;
}

/* ── Setup Screen ─────────────────────────────────── */
#setup-screen {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100vh;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
}
.setup-panel {
  background: #16213e;
  border: 1px solid #333;
  border-radius: 12px;
  padding: 32px 40px;
  width: 520px;
  max-height: 90vh;
  overflow-y: auto;
}
.setup-panel h1 { font-size: 28px; color: #e8d44d; margin-bottom: 4px; }
.setup-panel h2 { font-size: 14px; color: #888; font-weight: normal; margin-bottom: 24px; }
.setup-section { margin-bottom: 20px; }
.setup-section > label { display: block; font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; }
.setup-section input[type="file"] { font-size: 13px; color: #ccc; }
#board-info { font-size: 12px; color: #6a6; margin-top: 6px; min-height: 18px; }
#board-info.error { color: #c66; }
.player-count-btns { display: flex; gap: 8px; margin-bottom: 12px; }
.player-count-btns button {
  padding: 6px 18px; background: #1a1a2e; border: 1px solid #555; border-radius: 4px;
  color: #ccc; cursor: pointer; font-size: 13px;
}
.player-count-btns button.active { border-color: #4488cc; color: #fff; background: #0f3460; }
.player-row {
  display: grid;
  grid-template-columns: 30px 1fr 1fr 80px;
  gap: 8px;
  align-items: center;
  margin-bottom: 8px;
}
.player-row .player-dot { width: 18px; height: 18px; border-radius: 50%; }
.player-row input, .player-row select {
  padding: 5px 8px; background: #1a1a2e; border: 1px solid #555; border-radius: 4px;
  color: #fff; font-size: 12px;
}
.player-row select { cursor: pointer; }
.big-btn {
  display: block; width: 100%; padding: 12px; margin-top: 16px;
  background: #0f3460; border: 2px solid #4488cc; border-radius: 8px;
  color: #bbd; font-size: 16px; cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
}
.big-btn:hover:not(:disabled) { background: #1a4a80; color: #fff; }
.big-btn:disabled { opacity: 0.4; cursor: default; }

/* ── Game Screen ──────────────────────────────────── */
#game-screen {
  display: none;
  height: 100vh;
  grid-template-columns: 240px 1fr 260px;
  grid-template-rows: 1fr;
}
#game-screen.visible { display: grid; }

/* Sidebar */
#sidebar {
  background: #16213e;
  border-right: 1px solid #333;
  padding: 12px;
  overflow-y: auto;
  min-height: 0;
}
#sidebar h3 {
  font-size: 11px; text-transform: uppercase; letter-spacing: 1px;
  color: #666; margin: 12px 0 6px;
}
#sidebar h3:first-child { margin-top: 0; }
#phase-banner {
  text-align: center; padding: 4px 12px; font-size: 12px; font-weight: bold;
  color: #e8d44d; text-transform: uppercase; letter-spacing: 2px; background: #0f3460;
  border-bottom: 1px solid #333;
}
.stat-row { display: flex; justify-content: space-between; font-size: 13px; padding: 3px 0; }
.stat-row .label { color: #999; }
.stat-row .value { color: #fff; font-weight: bold; min-width: 30px; text-align: right; }
.stat-water .value { color: #40a0e0; }
.stat-swagger .value { color: #e8d44d; }
.stat-drive .value { color: #e07040; }
.stat-grit .value { color: #a0a0b0; }
.stat-bond .value { color: #e05080; }
.player-summary {
  display: flex; align-items: center; gap: 8px;
  padding: 5px 6px; border-radius: 4px; margin-bottom: 4px; font-size: 12px;
}
.player-summary.current { background: rgba(255,255,255,0.08); }
.player-summary .ps-dot { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; }
.player-summary .ps-name { flex: 1; }
.player-summary .ps-terr { color: #7ec850; font-weight: bold; }

/* Board area */
#board-area {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background: #1a1a2e;
}
#board-container {
  flex: 1;
  overflow: auto;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 12px;
  position: relative;
}
#board-svg { cursor: default; }
#board-svg .cell-rect { stroke: rgba(0,0,0,0.15); stroke-width: 0.5; }
#board-svg .cell-interactive { cursor: pointer; }
#board-svg .cell-interactive:hover { stroke: rgba(255,255,255,0.4); stroke-width: 1.5; }
#board-svg .highlight { fill: rgba(0,128,255,0.25); stroke: #0080ff; stroke-width: 2; pointer-events: none; }
#board-svg .highlight-action { fill: rgba(255,200,0,0.2); stroke: #ffc800; stroke-width: 2; pointer-events: none; }
#board-svg .pawn { stroke: #000; stroke-width: 2; }
#board-svg .pawn-label { fill: #000; font-size: 11px; font-weight: bold; pointer-events: none; }
#board-svg .fortify-badge { pointer-events: none; }
#board-svg .fortify-badge-bg { fill: #222; stroke: #fff; stroke-width: 1; }
#board-svg .fortify-badge-text { fill: #fff; font-size: 11px; font-weight: bold; }
#board-svg .owner-fill { pointer-events: none; opacity: 0.45; }
#board-svg .owner-border { fill: none; stroke-width: 4; opacity: 1; pointer-events: none; }

/* Controls bar */
#controls-bar {
  display: flex; align-items: center; gap: 12px;
  padding: 8px 16px; background: #0f3460; border-top: 1px solid #333;
  min-height: 48px; flex-wrap: wrap;
}
#controls-bar .ctrl-btn {
  padding: 5px 14px; background: #16213e; border: 1px solid #4488cc; border-radius: 4px;
  color: #bbd; font-size: 12px; cursor: pointer;
}
#controls-bar .ctrl-btn:hover { background: #1a4a80; color: #fff; }
#controls-bar .ctrl-btn.warn { border-color: #cc4444; color: #c88; }
#controls-bar .ctrl-btn.primary { border-color: #44cc88; color: #8dc; }
#controls-bar .ctrl-info { font-size: 13px; color: #aab; }
#controls-bar .ctrl-spacer { flex: 1; }

/* Dice */
#dice-display {
  display: none;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 100;
  gap: 12px;
  align-items: center;
  pointer-events: none;
}
#dice-display.visible { display: flex; }
.die {
  width: 48px; height: 48px; background: #fff; border-radius: 8px;
  display: flex; align-items: center; justify-content: center;
  font-size: 28px; font-weight: bold; color: #222;
  box-shadow: 3px 3px 8px rgba(0,0,0,0.5);
}
.die-eq { font-size: 20px; color: #fff; }
.die-total { font-size: 32px; font-weight: bold; color: #e8d44d; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }

/* Log panel */
#log-panel {
  background: #16213e;
  border-left: 1px solid #333;
  display: flex;
  flex-direction: column;
  min-height: 0;
}
#log-panel h3 {
  font-size: 11px; text-transform: uppercase; letter-spacing: 1px;
  color: #666; padding: 12px 12px 6px;
}
#game-log {
  flex: 1; overflow-y: auto; padding: 0 12px 12px; font-size: 12px; font-family: monospace;
}
.log-entry { padding: 2px 0; color: #999; border-bottom: 1px solid rgba(255,255,255,0.03); }
.log-entry.round { color: #e8d44d; font-weight: bold; margin-top: 8px; }
.log-entry.action { color: #7ec850; }
.log-entry.challenge { color: #e07040; }
.log-entry.system { color: #4488cc; }
.log-entry.reasoning { color: #b080d0; font-style: italic; }

/* Game over overlay */
#game-over {
  display: none;
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.7);
  z-index: 200;
  align-items: center;
  justify-content: center;
}
#game-over.visible { display: flex; }
#game-over .go-panel {
  background: #16213e; border: 2px solid #e8d44d; border-radius: 12px;
  padding: 32px 48px; text-align: center;
}
#game-over h2 { font-size: 32px; color: #e8d44d; margin-bottom: 8px; }
#game-over p { font-size: 16px; color: #ccc; margin-bottom: 24px; }
</style>
</head>
<body>

<!-- ── Setup Screen ──────────────────────────────── -->
<div id="setup-screen">
  <div class="setup-panel">
    <h1>Uri-Nation</h1>
    <h2>Game Runner</h2>

    <div class="setup-section">
      <label>Load Board JSON</label>
      <input type="file" id="board-file" accept=".json" />
      <div id="board-info"></div>
    </div>

    <div class="setup-section" id="player-setup" style="display:none">
      <label>Players</label>
      <div class="player-count-btns" id="count-btns"></div>
      <div id="player-configs"></div>
    </div>

    <div class="setup-section" id="api-key-section" style="display:none">
      <label>Anthropic API Key (required for Claude AI players)</label>
      <input type="password" id="api-key-input" placeholder="sk-ant-..."
             style="width:100%; padding:5px 8px; background:#1a1a2e; border:1px solid #555; border-radius:4px; color:#fff; font-size:12px;" />
      <div style="font-size:11px; color:#666; margin-top:4px;">Key is stored in sessionStorage only. Never sent anywhere except the Anthropic API.</div>
    </div>

    <button id="btn-start" class="big-btn" disabled>Start Game</button>
  </div>
</div>

<!-- ── Game Screen ───────────────────────────────── -->
<div id="game-screen">
  <div id="sidebar">
    <h3>Turn</h3>
    <div id="turn-info"></div>
    <h3>Current Player</h3>
    <div id="current-player-stats"></div>
    <h3>All Players</h3>
    <div id="all-players-summary"></div>
  </div>

  <div id="board-area">
    <div id="phase-banner">Setup</div>
    <div id="board-container">
      <svg id="board-svg" xmlns="http://www.w3.org/2000/svg"></svg>
      <div id="dice-display">
        <div class="die" id="die1"></div>
        <div class="die" id="die2"></div>
        <span class="die-eq">=</span>
        <span class="die-total" id="die-total"></span>
      </div>
    </div>
    <div id="controls-bar"></div>
  </div>

  <div id="log-panel">
    <h3>Game Log</h3>
    <div id="game-log"></div>
  </div>
</div>

<!-- ── Game Over Overlay ─────────────────────────── -->
<div id="game-over">
  <div class="go-panel">
    <h2 id="go-title"></h2>
    <p id="go-detail"></p>
    <button class="big-btn" onclick="exportLog()" style="border-color:#44cc88;color:#8dc;margin-bottom:8px">Export Log</button>
    <button class="big-btn" onclick="location.reload()">New Game</button>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════════
//  INLINED ENGINE (from tools/engine/ — v1.3.0)
//  Copied here so the file works standalone via file:// protocol.
// ═══════════════════════════════════════════════════════════════════════

// --- archetypes.js ---

const ARCHETYPES = {
  bruiser:  { name: 'Bruiser',  water: 6, swagger: 3, drive: 2, grit: 2, bond: 1 },
  scrapper: { name: 'Scrapper', water: 3, swagger: 2, drive: 3, grit: 1, bond: 2 },
  diplomat: { name: 'Diplomat', water: 4, swagger: 2, drive: 1, grit: 2, bond: 3 },
  yapper:   { name: 'Yapper',  water: 4, swagger: 1, drive: 2, grit: 3, bond: 2 },
};

// --- board.js ---

const SPACE_TYPES = {
  SIDEWALK:     'sidewalk',
  TERRITORY:    'territory',
  HOME:         'home',
  WATER_SOURCE: 'waterSource',
  CHANCE_SPOT:  'chanceSpot',
  DOG_PARK:     'dogPark',
  EVENTS:       'events',
  INTERSECTION: 'intersection',
  PATH:         'path',
  SIDE_STREET:  'sideStreet',
};

function defaultSpaceState() {
  return { owner: null, fortifyTokens: 0 };
}

class Board {
  constructor() {
    this.spaces = new Map();
    this.edges = new Map();
  }
  static fromJSON(json) {
    const b = new Board();
    for (const s of json.spaces) b.addSpace(s);
    for (const e of json.edges) b.addEdge(e.from, e.to, e.driveCost || 0);
    return b;
  }
  addSpace(def) {
    this.spaces.set(def.id, {
      id:           def.id,
      type:         def.type,
      label:        def.label        || def.id,
      facing:       def.facing       || null,
      playerColour: def.playerColour || null,
      pathExit:     def.pathExit     || null,
      ...defaultSpaceState(),
    });
  }
  addEdge(fromId, toId, driveCost = 0) {
    if (!this.edges.has(fromId)) this.edges.set(fromId, []);
    if (!this.edges.has(toId))   this.edges.set(toId, []);
    this.edges.get(fromId).push({ target: toId, driveCost });
    this.edges.get(toId).push({ target: fromId, driveCost });
  }
  getSpace(id)       { return this.spaces.get(id) || null; }
  getNeighbors(id)   { return (this.edges.get(id) || []).map(e => ({ space: this.spaces.get(e.target), driveCost: e.driveCost })); }
  getEdges(id)       { return this.edges.get(id) || []; }
  getSpacesByType(t) { const o = []; for (const s of this.spaces.values()) if (s.type === t) o.push(s); return o; }
  getTerritoriesOwnedBy(pid) { const o = []; for (const s of this.spaces.values()) if (s.type === SPACE_TYPES.TERRITORY && s.owner === pid) o.push(s); return o; }
  getAllSpaces()      { return [...this.spaces.values()]; }
  getHomeSpace(playerId, players) {
    const player = players.find(p => p.id === playerId);
    if (!player) return null;
    for (const s of this.spaces.values()) {
      if (s.type === SPACE_TYPES.HOME && s.playerColour === player.colour) return s;
    }
    return null;
  }
  getHomeNeighbourhood(playerId, players) {
    const home = this.getHomeSpace(playerId, players);
    if (!home) return [];
    return this.getNeighbors(home.id)
      .filter(n => n.space.type === SPACE_TYPES.TERRITORY)
      .map(n => n.space);
  }
  isHomeNeighbourhood(territoryId, playerId, players) {
    return this.getHomeNeighbourhood(playerId, players).some(s => s.id === territoryId);
  }
  areAllied(playerIdA, playerIdB, players) {
    const a = players.find(p => p.id === playerIdA);
    return a ? a.allies.includes(playerIdB) : false;
  }
  getMovementCost(fromId, toId) {
    const edges = this.edges.get(fromId);
    if (!edges) return null;
    const e = edges.find(e => e.target === toId);
    return e ? e.driveCost : null;
  }
  getConnectedTerritoryGroups(pid) {
    const owned = new Set();
    for (const s of this.spaces.values()) if (s.type === SPACE_TYPES.TERRITORY && s.owner === pid) owned.add(s.id);
    const visited = new Set(); const groups = [];
    for (const id of owned) {
      if (visited.has(id)) continue;
      const group = []; const stack = [id];
      while (stack.length > 0) {
        const cur = stack.pop();
        if (visited.has(cur)) continue;
        visited.add(cur); group.push(cur);
        for (const e of (this.edges.get(cur) || [])) if (owned.has(e.target) && !visited.has(e.target)) stack.push(e.target);
      }
      groups.push(group);
    }
    return groups;
  }
  isInCluster(tid, pid) {
    for (const g of this.getConnectedTerritoryGroups(pid)) if (g.includes(tid) && g.length >= 3) return true;
    return false;
  }
  resetState() { for (const s of this.spaces.values()) Object.assign(s, defaultSpaceState()); }
  toJSON() {
    const spaces = []; for (const s of this.spaces.values()) spaces.push({ ...s });
    const edges = []; const seen = new Set();
    for (const [fid, conns] of this.edges) for (const c of conns) {
      const key = [fid, c.target].sort().join('|');
      if (seen.has(key)) continue; seen.add(key);
      edges.push({ from: fid, to: c.target, driveCost: c.driveCost });
    }
    return { spaces, edges };
  }
}

// --- game.js ---

const DEFAULTS = {
  swaggerPerTerritories: 3,
  maxFortify:            1,
  maxTurns:              30,
  territoryWinThreshold: 15,
};

function createPlayer(id, archetypeKey, homeSpaceId, colour) {
  const arch = ARCHETYPES[archetypeKey];
  if (!arch) throw new Error(`Unknown archetype: ${archetypeKey}`);
  return {
    id, colour, archetype: archetypeKey, position: homeSpaceId,
    water: arch.water, swagger: arch.swagger, drive: arch.drive, grit: arch.grit, bond: arch.bond,
    allies: [],
  };
}

class Game {
  constructor(board, players, config = {}) {
    this.board = board; this.players = players;
    this.config = { ...DEFAULTS, ...config };
    this.turnNumber = 0; this.currentPlayerIndex = 0;
    this.gameOver = false; this.winner = null; this.log = [];
    this.pendingAlliances = new Map();
  }
  getPlayer(id)        { return this.players.find(p => p.id === id); }
  getCurrentPlayer()   { return this.players[this.currentPlayerIndex]; }
  getArchetype(player) { return ARCHETYPES[player.archetype]; }
  calculateSwaggerIncome(pid) {
    let total = 0;
    for (const g of this.board.getConnectedTerritoryGroups(pid)) total += Math.floor(g.length / this.config.swaggerPerTerritories);
    return total;
  }
  applyTerritoryIncome(pid) {
    const p = this.getPlayer(pid);
    const sw = this.calculateSwaggerIncome(pid);
    if (sw > 0) { p.swagger += sw; this._log(pid, `territory income: +${sw} swagger`); }
  }

  // ── Validation ──
  canClaim(pid, tid) {
    const p = this.getPlayer(pid), s = this.board.getSpace(tid);
    if (!s || s.type !== SPACE_TYPES.TERRITORY) return { ok: false, reason: 'Not a territory' };
    if (s.owner !== null) return { ok: false, reason: 'Occupied' };
    if (p.water < 2) return { ok: false, reason: 'Need 2 water' };
    if (p.swagger < 1) return { ok: false, reason: 'Need 1 swagger' };
    return { ok: true, waterCost: 2, swaggerCost: 1 };
  }
  canChallenge(pid, tid) {
    const p = this.getPlayer(pid), s = this.board.getSpace(tid);
    if (!s) return { ok: false, reason: 'Space not found' };
    if (s.type === SPACE_TYPES.HOME) return { ok: false, reason: 'Cannot challenge a home turf' };
    if (s.type !== SPACE_TYPES.TERRITORY) return { ok: false, reason: 'Not a territory' };
    if (s.owner === null) return { ok: false, reason: 'Empty — use Claim' };
    if (s.owner === pid) return { ok: false, reason: 'Own territory' };
    if (p.water < 2) return { ok: false, reason: 'Need 2 water' };
    if (p.drive < 1) return { ok: false, reason: 'Need 1 drive' };
    if (this.board.areAllied(pid, s.owner, this.players)) return { ok: false, reason: 'Alliance protection' };
    // Home neighbourhood transitive check
    if (this.board.isHomeNeighbourhood(tid, s.owner, this.players)) {
      const defender = this.getPlayer(s.owner);
      for (const allyId of defender.allies) {
        if (this.board.areAllied(pid, allyId, this.players))
          return { ok: false, reason: 'Alliance protection — home neighbourhood' };
      }
    }
    return { ok: true, waterCost: 2, driveCost: 1 };
  }
  canFortify(pid, tid) {
    const p = this.getPlayer(pid), s = this.board.getSpace(tid);
    if (!s || s.type !== SPACE_TYPES.TERRITORY) return { ok: false, reason: 'Not a territory' };
    if (s.owner !== pid) return { ok: false, reason: 'Not yours' };
    if (s.fortifyTokens >= this.config.maxFortify) return { ok: false, reason: 'Max fortify' };
    if (p.water < 1) return { ok: false, reason: 'Need 1 water' };
    if (p.grit < 1) return { ok: false, reason: 'Need 1 grit' };
    return { ok: true, waterCost: 1, gritCost: 1 };
  }
  canAlly(pid, dogParkSpaceId) {
    const p = this.getPlayer(pid), s = this.board.getSpace(dogParkSpaceId);
    if (!s || s.type !== SPACE_TYPES.DOG_PARK) return { ok: false, reason: 'Not a dog park' };
    if (p.water < 1) return { ok: false, reason: 'Need 1 water' };
    if (p.bond < 1) return { ok: false, reason: 'Need 1 bond' };
    return { ok: true, waterCost: 1, bondCost: 1 };
  }
  canBreakAlliance(pid, alliedPlayerId) {
    const p = this.getPlayer(pid);
    if (!p.allies.includes(alliedPlayerId)) return { ok: false, reason: 'Not allied' };
    if (p.water < 1) return { ok: false, reason: 'Need 1 water' };
    if (p.swagger < 1) return { ok: false, reason: 'Need 1 swagger' };
    return { ok: true, waterCost: 1, swaggerCost: 1 };
  }
  canDrink(pid) {
    const p = this.getPlayer(pid);
    if (p.drive < 1) return { ok: false, reason: 'Need 1 drive' };
    return { ok: true, driveCost: 1 };
  }
  canReClaim(pid) {
    const p = this.getPlayer(pid);
    if (p.swagger >= 1) return { ok: true, resource: 'swagger' };
    if (p.grit >= 1)    return { ok: true, resource: 'grit' };
    return { ok: false, reason: 'Need 1 swagger or 1 grit' };
  }

  // ── Actions ──
  claim(pid, tid) {
    const c = this.canClaim(pid, tid); if (!c.ok) return { success: false, reason: c.reason };
    const p = this.getPlayer(pid), s = this.board.getSpace(tid);
    p.water -= c.waterCost; p.swagger -= c.swaggerCost; s.owner = pid;
    this._log(pid, `claimed ${tid}`); return { success: true };
  }
  payChallengeCost(pid, tid) {
    const c = this.canChallenge(pid, tid); if (!c.ok) return { success: false, reason: c.reason };
    const p = this.getPlayer(pid);
    p.water -= c.waterCost; p.drive -= c.driveCost;
    this._log(pid, `paid challenge cost for ${tid}`);
    return { success: true, defenderId: this.board.getSpace(tid).owner };
  }
  resolveChallenge(attackerId, defenderId, tid, attackRoll, defendRoll) {
    const att = this.getPlayer(attackerId), def = this.getPlayer(defenderId), space = this.board.getSpace(tid);
    let aT = attackRoll, dT = defendRoll;
    dT += space.fortifyTokens;
    const cluster = this.board.isInCluster(tid, defenderId);
    let outcome;
    if (aT > dT) outcome = 'attackerWins';
    else if (aT === dT) outcome = cluster ? 'defenderWins' : 'tie';
    else outcome = 'defenderWins';
    const result = { outcome, attackRoll, defendRoll, attackTotal: aT, defendTotal: dT, fortifyBonus: space.fortifyTokens, clusterRule: cluster };
    if (outcome === 'attackerWins') {
      space.owner = null; space.fortifyTokens = 0;
      result.canReClaim = this.canReClaim(attackerId);
      this._log(attackerId, `won challenge at ${tid} (${aT} vs ${dT})`);
    } else if (outcome === 'defenderWins') {
      this._log(attackerId, `lost challenge at ${tid}`);
    }
    return result;
  }
  reClaim(pid, tid, useResource) {
    const p = this.getPlayer(pid), s = this.board.getSpace(tid);
    if (useResource === 'swagger') { if (p.swagger < 1) return { success: false }; p.swagger -= 1; }
    else if (useResource === 'grit') { if (p.grit < 1) return { success: false }; p.grit -= 1; }
    else return { success: false };
    s.owner = pid;
    this._log(pid, `re-claimed ${tid} with ${useResource}`); return { success: true };
  }
  declineReClaim(tid) { this._log(null, `re-claim declined at ${tid}`); return { success: true }; }
  fortify(pid, tid) {
    const c = this.canFortify(pid, tid); if (!c.ok) return { success: false, reason: c.reason };
    const p = this.getPlayer(pid), s = this.board.getSpace(tid);
    p.water -= c.waterCost; p.grit -= c.gritCost; s.fortifyTokens += 1;
    this._log(pid, `fortified ${tid} (${s.fortifyTokens}/${this.config.maxFortify})`); return { success: true };
  }

  // ── Alliance ──
  ally(pid, dogParkSpaceId) {
    const c = this.canAlly(pid, dogParkSpaceId); if (!c.ok) return { success: false, reason: c.reason };
    const p = this.getPlayer(pid);
    p.water -= c.waterCost; p.bond -= c.bondCost;
    this.pendingAlliances.set(dogParkSpaceId, pid);
    this._log(pid, `initiated alliance at ${dogParkSpaceId}`); return { success: true };
  }
  compulsoryBondJoin(pid, dogParkSpaceId) {
    const p = this.getPlayer(pid);
    if (!this.pendingAlliances.has(dogParkSpaceId)) return { success: false, reason: 'No pending alliance' };
    const initiatorId = this.pendingAlliances.get(dogParkSpaceId);
    if (initiatorId === pid) return { success: false, reason: 'Cannot join own alliance' };
    if (p.allies.includes(initiatorId)) return { success: false, reason: 'Already allied' };
    if (p.water < 1) return { success: false, reason: 'No water' };
    const initiator = this.getPlayer(initiatorId);
    p.water -= 1;
    if (!p.allies.includes(initiatorId)) p.allies.push(initiatorId);
    if (!initiator.allies.includes(pid)) initiator.allies.push(pid);
    this.pendingAlliances.delete(dogParkSpaceId);
    this._log(pid, `joined alliance with ${initiatorId} at ${dogParkSpaceId}`);
    // Friendship sacrifice: clear claims in each other's home neighbourhood
    const cleared = [];
    const joinerHood = this.board.getHomeNeighbourhood(pid, this.players);
    for (const t of joinerHood) {
      if (t.owner === initiatorId) {
        t.owner = null; t.fortifyTokens = 0; cleared.push(t.id);
        this._log(initiatorId, `claim cleared at ${t.id} (friendship sacrifice)`);
      }
    }
    const initiatorHood = this.board.getHomeNeighbourhood(initiatorId, this.players);
    for (const t of initiatorHood) {
      if (t.owner === pid) {
        t.owner = null; t.fortifyTokens = 0; cleared.push(t.id);
        this._log(pid, `claim cleared at ${t.id} (friendship sacrifice)`);
      }
    }
    return { success: true, cleared };
  }
  breakAlliance(pid, alliedPlayerId) {
    const c = this.canBreakAlliance(pid, alliedPlayerId); if (!c.ok) return { success: false, reason: c.reason };
    const p = this.getPlayer(pid), ally = this.getPlayer(alliedPlayerId);
    p.water -= c.waterCost; p.swagger -= c.swaggerCost;
    p.allies = p.allies.filter(id => id !== alliedPlayerId);
    ally.allies = ally.allies.filter(id => id !== pid);
    this._log(pid, `broke alliance with ${alliedPlayerId}`); return { success: true };
  }

  // ── Shortcut ──
  takeShortcut(pid, pathEntryId) {
    const p = this.getPlayer(pid), s = this.board.getSpace(pathEntryId);
    if (!s || s.type !== SPACE_TYPES.PATH) return { success: false, reason: 'Not a path space' };
    if (p.position !== pathEntryId) return { success: false, reason: 'Not at path entry' };
    if (!s.pathExit) return { success: false, reason: 'No exit' };
    if (p.drive < 1) return { success: false, reason: 'Need 1 drive' };
    p.drive -= 1; p.position = s.pathExit;
    this._log(pid, `took shortcut ${pathEntryId} → ${s.pathExit}`);
    return { success: true, exitSpaceId: s.pathExit };
  }

  // ── Drink ──
  drink(pid, waterGain) {
    const c = this.canDrink(pid); if (!c.ok) return { success: false, reason: c.reason };
    const p = this.getPlayer(pid), arch = this.getArchetype(p);
    p.drive -= c.driveCost; p.water = Math.min(p.water + waterGain, arch.water);
    this._log(pid, `drank: +${waterGain} water (now ${p.water}/${arch.water})`); return { success: true };
  }

  // ── Movement ──
  getPassThroughEffects(spaceId, pid) {
    const s = this.board.getSpace(spaceId); if (!s) return [];
    const effects = [];
    switch (s.type) {
      case SPACE_TYPES.CHANCE_SPOT: effects.push({ type: 'chanceCard' }); break;
      case SPACE_TYPES.DOG_PARK:
        if (this.pendingAlliances.has(spaceId)) {
          const initId = this.pendingAlliances.get(spaceId);
          const player = this.getPlayer(pid);
          if (initId !== pid && player && !player.allies.includes(initId)) {
            effects.push({ type: 'compulsoryBond', dogParkSpaceId: spaceId }); break;
          }
        }
        effects.push({ type: 'dogPark' }); break;
      case SPACE_TYPES.EVENTS: effects.push({ type: 'eventsCard' }); break;
      case SPACE_TYPES.HOME: {
        const player = this.getPlayer(pid);
        if (player && s.playerColour === player.colour) effects.push({ type: 'homeResupply' });
        break;
      }
      case SPACE_TYPES.PATH:
        if (s.pathExit) effects.push({ type: 'pathEntry', exitSpaceId: s.pathExit });
        break;
    }
    return effects;
  }
  movePlayer(pid, path) {
    const p = this.getPlayer(pid);
    if (path.length === 0) return { success: true, driveCost: 0, effects: [] };
    if (path[0] !== p.position) return { success: false, reason: 'Path must start at current position' };
    let totalDrive = 0;
    for (let i = 1; i < path.length; i++) {
      const cost = this.board.getMovementCost(path[i-1], path[i]);
      if (cost === null) return { success: false, reason: `No connection: ${path[i-1]} -> ${path[i]}` };
      totalDrive += cost;
    }
    if (p.drive < totalDrive) return { success: false, reason: `Not enough drive (need ${totalDrive})` };
    const effects = [];
    for (let i = 1; i < path.length; i++) {
      for (const eff of this.getPassThroughEffects(path[i], pid)) effects.push({ ...eff, spaceId: path[i] });
    }
    p.drive -= totalDrive; p.position = path[path.length - 1];
    this._log(pid, `moved to ${p.position} (${totalDrive} drive)`);
    return { success: true, driveCost: totalDrive, effects };
  }
  applyDogPark(pid) { this.getPlayer(pid).bond += 1; this._log(pid, '+1 bond (dog park)'); }
  applyHomeResupply(pid) {
    const p = this.getPlayer(pid), arch = this.getArchetype(p);
    p.water = arch.water;
    p.swagger = Math.max(p.swagger, arch.swagger);
    p.drive   = Math.max(p.drive, arch.drive);
    p.grit    = Math.max(p.grit, arch.grit);
    p.bond    = Math.max(p.bond, arch.bond);
    this._log(pid, 'home resupply');
  }

  // ── Win conditions ──
  checkWinConditions() {
    for (const p of this.players) {
      const c = this.board.getTerritoriesOwnedBy(p.id).length;
      if (c >= this.config.territoryWinThreshold) {
        this.gameOver = true; this.winner = p.id;
        this._log(p.id, `wins — ${c} territories!`);
        return { gameOver: true, winner: p.id, reason: 'territory threshold' };
      }
    }
    // Last-dog-standing: only check at end of a full round (after all players have gone)
    // and only after round 5 to give everyone time to recover from early losses
    if (this.turnNumber >= 5 && this.currentPlayerIndex >= this.players.length - 1) {
      const wt = this.players.filter(p => this.board.getTerritoriesOwnedBy(p.id).length > 0);
      if (wt.length === 1) {
        this.gameOver = true; this.winner = wt[0].id;
        return { gameOver: true, winner: wt[0].id, reason: 'last standing' };
      }
    }
    if (this.turnNumber >= this.config.maxTurns) {
      const ranked = [...this.players].sort((a, b) => {
        const aT = this.board.getTerritoriesOwnedBy(a.id), bT = this.board.getTerritoriesOwnedBy(b.id);
        if (bT.length !== aT.length) return bT.length - aT.length;
        const aF = aT.reduce((s,t) => s+t.fortifyTokens,0), bF = bT.reduce((s,t) => s+t.fortifyTokens,0);
        if (bF !== aF) return bF - aF;
        return b.swagger - a.swagger;
      });
      this.gameOver = true; this.winner = ranked[0].id;
      return { gameOver: true, winner: ranked[0].id, reason: 'turn limit', rankings: ranked.map(p => p.id) };
    }
    return { gameOver: false };
  }

  // ── Turn management ──
  startRound() {
    this.turnNumber += 1; this.currentPlayerIndex = 0;
    this._log(null, `=== Round ${this.turnNumber} ===`);
  }
  advancePlayer() { this.currentPlayerIndex += 1; return this.currentPlayerIndex < this.players.length; }

  static rollD6(rng) { if (rng) return rng(1, 6); return Math.floor(Math.random() * 6) + 1; }
  static roll2D6(rng) { return Game.rollD6(rng) + Game.rollD6(rng); }
  rollMovement(pid, rng) {
    return Game.roll2D6(rng);
  }
  getState() {
    return {
      turnNumber: this.turnNumber, currentPlayerIndex: this.currentPlayerIndex,
      gameOver: this.gameOver, winner: this.winner,
      players: this.players.map(p => ({ ...p, allies: [...p.allies] })),
      board: this.board.toJSON(),
      pendingAlliances: Object.fromEntries(this.pendingAlliances),
      log: [...this.log],
    };
  }
  _log(pid, msg) { this.log.push({ turn: this.turnNumber, player: pid, message: msg }); }
}

// ═══════════════════════════════════════════════════════════════════════
//  CONSTANTS & GLOBALS
// ═══════════════════════════════════════════════════════════════════════

const COLOUR_HEX = { blue: '#5080e0', purple: '#9060c0', orange: '#e0a050', yellow: '#e0d050' };
const COLOUR_ORDER = ['blue', 'purple', 'orange', 'yellow'];
const SVG_NS = 'http://www.w3.org/2000/svg';
const CELL = 64;

// ── Stamp footprints (inlined from board-builder) ──

const COMPOUND_FP = [
  // rot 0  N — yard on top
  [{dr:0,dc:0,sub:'yard'},{dr:0,dc:1,sub:'yard'},
   {dr:1,dc:0,sub:'house'},{dr:1,dc:1,sub:'house'},
   {dr:2,dc:0,sub:'house'},{dr:2,dc:1,sub:'house'}],
  // rot 1  E — yard on right
  [{dr:0,dc:0,sub:'house'},{dr:0,dc:1,sub:'house'},{dr:0,dc:2,sub:'yard'},
   {dr:1,dc:0,sub:'house'},{dr:1,dc:1,sub:'house'},{dr:1,dc:2,sub:'yard'}],
  // rot 2  S — yard on bottom
  [{dr:0,dc:0,sub:'house'},{dr:0,dc:1,sub:'house'},
   {dr:1,dc:0,sub:'house'},{dr:1,dc:1,sub:'house'},
   {dr:2,dc:0,sub:'yard'},{dr:2,dc:1,sub:'yard'}],
  // rot 3  W — yard on left
  [{dr:0,dc:0,sub:'yard'},{dr:0,dc:1,sub:'house'},{dr:0,dc:2,sub:'house'},
   {dr:1,dc:0,sub:'yard'},{dr:1,dc:1,sub:'house'},{dr:1,dc:2,sub:'house'}],
];

const STAMP_FP = {
  sidewalk: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:1,dc:0,sub:'main'}],
    ],
    colors: {main:'#d4b896'},
  },
  road: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:1,dc:0,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'}],
    ],
    colors: {main:'#888888'},
  },
  intersection: {
    fp: [[{dr:0,dc:0,sub:'main'}]],
    colors: {main:'#aaaaaa'},
  },
  territory: {
    fp: COMPOUND_FP,
    colors: {yard:'#7ec850', house:'#c87850'},
  },
  home: {
    fp: COMPOUND_FP,
    colors: {yard:'#88aaff', house:'#4477dd'},
  },
  dogPark: {
    fp: [[{dr:0,dc:0,sub:'main'}]],
    colors: {main:'#40c080'},
  },
  waterPark: {
    fp: [[{dr:0,dc:0,sub:'main'}]],
    colors: {main:'#40a8a0'},
  },
  pathStraight: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:1,dc:0,sub:'main'}],
    ],
    colors: {main:'#c8a878'},
  },
  pathCorner: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:1,dc:1,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:1,dc:1,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:1,dc:1,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:1,dc:1,sub:'main'}],
    ],
    colors: {main:'#c8a878'},
  },
  sidewalk3: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:0,dc:2,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:2,dc:0,sub:'main'}],
    ],
    colors: {main:'#d4b896'},
  },
  road3: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:2,dc:0,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:0,dc:2,sub:'main'}],
    ],
    colors: {main:'#888888'},
  },
  pathStraight3: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:0,dc:2,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:2,dc:0,sub:'main'}],
    ],
    colors: {main:'#c8a878'},
  },
};

const HOME_PLAYER_COLORS = {
  blue:   {yard:'#88aaff', house:'#4477dd'},
  purple: {yard:'#cc88ff', house:'#8844cc'},
  orange: {yard:'#ffbb66', house:'#dd8833'},
  yellow: {yard:'#ffee66', house:'#ccbb33'},
};

function getStampCells(type, rot) {
  const s = STAMP_FP[type];
  if (!s) return [];
  return s.fp[rot % s.fp.length];
}

function getCellColor(type, sub, playerColour) {
  if (type === 'home' && playerColour && HOME_PLAYER_COLORS[playerColour])
    return HOME_PLAYER_COLORS[playerColour][sub] || '#888';
  return STAMP_FP[type]?.colors[sub] || '#555';
}

let boardData = null;       // raw JSON
let board = null;           // Board instance
let game = null;            // Game instance
let playerConfigs = [];     // { id, name, archetype, isAI, homeSpaceId, colour }
let positions = {};         // spaceId → { x, y } in SVG coords (first cell center)
let cellToSpaceId = {};     // "row,col" → spaceId
let spaceIdToCells = {};    // spaceId → [{row,col}, ...]
let gridRows = 0, gridCols = 0;
let svgEl = null;
let layerCells, layerOverlay, layerHighlight, layerPawns;

// Interaction promises
let _resolveSpaceClick = null;
let _validSpaceIds = null;
let _resolveControlBtn = null;

// ═══════════════════════════════════════════════════════════════════════
//  SETUP SCREEN
// ═══════════════════════════════════════════════════════════════════════

function initSetup() {
  document.getElementById('board-file').addEventListener('change', onBoardFileChange);

  // Player count buttons
  const countBtns = document.getElementById('count-btns');
  for (let n = 2; n <= 4; n++) {
    const btn = document.createElement('button');
    btn.textContent = n;
    btn.dataset.count = n;
    if (n === 2) btn.classList.add('active');
    btn.addEventListener('click', () => {
      countBtns.querySelectorAll('button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      buildPlayerConfigRows(n);
    });
    countBtns.appendChild(btn);
  }

  document.getElementById('btn-start').addEventListener('click', onStartGame);
}

function onBoardFileChange(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      boardData = JSON.parse(ev.target.result);
      const homeCount = boardData.spaces.filter(s => s.type === SPACE_TYPES.HOME).length;
      const info = document.getElementById('board-info');
      info.textContent = `${boardData.spaces.length} spaces, ${boardData.edges.length} edges, ${homeCount} homes`;
      info.className = '';
      document.getElementById('player-setup').style.display = '';

      // Limit player count to available homes
      const maxPlayers = Math.min(4, homeCount);
      const countBtns = document.getElementById('count-btns');
      countBtns.querySelectorAll('button').forEach(b => {
        const n = parseInt(b.dataset.count);
        b.disabled = n > maxPlayers;
        b.classList.remove('active');
      });
      // Select first valid count
      const firstValid = countBtns.querySelector(`button:not(:disabled)`);
      if (firstValid) { firstValid.classList.add('active'); buildPlayerConfigRows(parseInt(firstValid.dataset.count)); }

      document.getElementById('btn-start').disabled = homeCount < 2;
    } catch (err) {
      const info = document.getElementById('board-info');
      info.textContent = 'Error: ' + err.message;
      info.className = 'error';
    }
  };
  reader.readAsText(file);
}

function buildPlayerConfigRows(count) {
  const container = document.getElementById('player-configs');
  container.innerHTML = '';
  const archetypeKeys = Object.keys(ARCHETYPES);
  for (let i = 0; i < count; i++) {
    const colour = COLOUR_HEX[COLOUR_ORDER[i]] || '#888';
    const row = document.createElement('div');
    row.className = 'player-row';
    row.innerHTML = `
      <span class="player-dot" style="background:${colour}"></span>
      <input type="text" value="Player ${i+1}" data-field="name" />
      <select data-field="archetype">
        ${archetypeKeys.map((k, j) => `<option value="${k}" ${j === i % archetypeKeys.length ? 'selected' : ''}>${ARCHETYPES[k].name}</option>`).join('')}
      </select>
      <select data-field="control">
        <option value="human" ${i === 0 ? 'selected' : ''}>Human</option>
        <option value="ai">AI (Algorithmic)</option>
        <option value="claude" ${i > 0 ? 'selected' : ''}>Claude AI</option>
      </select>
    `;
    container.appendChild(row);
  }

  // Wire up control change listeners to show/hide API key section
  container.querySelectorAll('[data-field="control"]').forEach(sel => {
    sel.addEventListener('change', updateApiKeyVisibility);
  });
  updateApiKeyVisibility();

  // Load saved API key
  const savedKey = sessionStorage.getItem('anthropic_api_key');
  if (savedKey) document.getElementById('api-key-input').value = savedKey;
}

function updateApiKeyVisibility() {
  const controls = document.querySelectorAll('#player-configs [data-field="control"]');
  const hasClaude = [...controls].some(sel => sel.value === 'claude');
  document.getElementById('api-key-section').style.display = hasClaude ? 'block' : 'none';
}

function onStartGame() {
  if (!boardData) return;
  const rows = document.querySelectorAll('#player-configs .player-row');
  const homes = boardData.spaces.filter(s => s.type === SPACE_TYPES.HOME);

  playerConfigs = [];
  board = Board.fromJSON(boardData);

  for (let i = 0; i < rows.length; i++) {
    const name = rows[i].querySelector('[data-field="name"]').value.trim() || `Player ${i+1}`;
    const archetype = rows[i].querySelector('[data-field="archetype"]').value;
    const controlVal = rows[i].querySelector('[data-field="control"]').value;
    const isAI = controlVal === 'ai' || controlVal === 'claude';
    const isClaude = controlVal === 'claude';
    const homeId = homes[i].id;
    const id = `p${i+1}`;
    // Read colour from the home space's playerColour field
    const homeSpace = board.getSpace(homeId);
    const colour = (homeSpace && homeSpace.playerColour) || COLOUR_ORDER[i];
    playerConfigs.push({ id, name, archetype, isAI, isClaude, homeSpaceId: homeId, colour });
  }

  // Build position map from _positions
  buildPositionMap();

  // Create players (v1.3.0: pass colour)
  const players = playerConfigs.map(c => createPlayer(c.id, c.archetype, c.homeSpaceId, c.colour));
  game = new Game(board, players);

  // Starting claim: each player gets one free adjacent territory
  for (const p of players) {
    const homeNeighbors = board.getHomeNeighbourhood(p.id, players);
    const unclaimed = homeNeighbors.find(t => t.owner === null);
    if (unclaimed) {
      unclaimed.owner = p.id;
      game._log(p.id, `starting claim: ${unclaimed.id}`);
    }
  }

  // Save API key to sessionStorage
  const apiKeyVal = document.getElementById('api-key-input').value.trim();
  if (apiKeyVal) sessionStorage.setItem('anthropic_api_key', apiKeyVal);

  // Switch to game screen
  document.getElementById('setup-screen').style.display = 'none';
  document.getElementById('game-screen').classList.add('visible');

  // Build SVG
  buildBoardSVG();
  updateOverlay();
  updatePawns();
  updateSidebar();

  // Start the game loop
  runGame();
}

// ═══════════════════════════════════════════════════════════════════════
//  POSITION MAP
// ═══════════════════════════════════════════════════════════════════════

function buildPositionMap() {
  positions = {};
  cellToSpaceId = {};
  spaceIdToCells = {};
  gridRows = 0;
  gridCols = 0;

  if (boardData._grid) {
    gridRows = boardData._grid.rows || 0;
    gridCols = boardData._grid.cols || 0;
  }

  if (boardData._positions && boardData._positions.length > 0) {
    for (const p of boardData._positions) {
      const key = `${p.row},${p.col}`;
      cellToSpaceId[key] = p.id;
      if (!spaceIdToCells[p.id]) spaceIdToCells[p.id] = [];
      spaceIdToCells[p.id].push({ row: p.row, col: p.col });
      // First occurrence becomes the pawn position
      if (!positions[p.id]) {
        positions[p.id] = { x: p.col * CELL + CELL / 2, y: p.row * CELL + CELL / 2 };
      }
    }
  } else {
    // Fallback: arrange in a grid
    const count = boardData.spaces.length;
    const cols = Math.ceil(Math.sqrt(count * 1.5));
    gridCols = cols;
    gridRows = Math.ceil(count / cols);
    boardData.spaces.forEach((s, i) => {
      const col = i % cols;
      const row = Math.floor(i / cols);
      positions[s.id] = { x: col * CELL + CELL / 2, y: row * CELL + CELL / 2 };
      const key = `${row},${col}`;
      cellToSpaceId[key] = s.id;
      spaceIdToCells[s.id] = [{ row, col }];
    });
  }
}

// ═══════════════════════════════════════════════════════════════════════
//  SVG RENDERER
// ═══════════════════════════════════════════════════════════════════════

function buildBoardSVG() {
  svgEl = document.getElementById('board-svg');
  svgEl.innerHTML = '';

  // ViewBox from grid dimensions
  const vw = gridCols * CELL;
  const vh = gridRows * CELL;
  svgEl.setAttribute('viewBox', `0 0 ${vw} ${vh}`);
  svgEl.setAttribute('width', vw);
  svgEl.setAttribute('height', vh);

  // Background
  const bg = svgCreate('rect', { x: 0, y: 0, width: vw, height: vh, fill: '#2a2a3e' });
  svgEl.appendChild(bg);

  // Layers
  layerCells     = svgG('cells-layer');
  layerOverlay   = svgG('overlay-layer');
  layerHighlight = svgG('highlight-layer');
  layerPawns     = svgG('pawns-layer');
  svgEl.append(layerCells, layerOverlay, layerHighlight, layerPawns);

  // Paint grid components
  if (boardData._grid && boardData._grid.components) {
    for (const comp of boardData._grid.components) {
      const cells = getStampCells(comp.type, comp.rotation);
      for (const cell of cells) {
        const absRow = comp.row + cell.dr;
        const absCol = comp.col + cell.dc;
        const x = absCol * CELL;
        const y = absRow * CELL;
        const fill = getCellColor(comp.type, cell.sub, comp.playerColour);
        const key = `${absRow},${absCol}`;
        const spaceId = cellToSpaceId[key] || null;

        const rect = svgCreate('rect', {
          x, y, width: CELL, height: CELL,
          fill,
          class: 'cell-rect' + (spaceId ? ' cell-interactive' : ''),
        });
        if (spaceId) rect.dataset.spaceId = spaceId;
        layerCells.appendChild(rect);
      }
    }
  }

  // Click handler (event delegation)
  svgEl.addEventListener('click', (e) => {
    const el = e.target.closest('[data-space-id]');
    if (!el) return;
    const sid = el.dataset.spaceId;
    if (_resolveSpaceClick && _validSpaceIds && _validSpaceIds.includes(sid)) {
      _resolveSpaceClick(sid);
      _resolveSpaceClick = null;
      _validSpaceIds = null;
    }
  });
}

function updateOverlay() {
  layerOverlay.innerHTML = '';
  for (const s of board.getAllSpaces()) {
    const cells = spaceIdToCells[s.id];
    if (!cells || cells.length === 0) continue;

    // Owned territory — fill cells with player color
    if (s.owner) {
      const cfg = playerConfigs.find(c => c.id === s.owner);
      if (cfg) {
        const colour = COLOUR_HEX[cfg.colour] || cfg.colour;
        // Color fill on each cell
        for (const cell of cells) {
          const fill = svgCreate('rect', {
            x: cell.col * CELL, y: cell.row * CELL,
            width: CELL, height: CELL,
            fill: colour, class: 'owner-fill',
          });
          layerOverlay.appendChild(fill);
        }
        // Prominent border around each cell
        for (const cell of cells) {
          const border = svgCreate('rect', {
            x: cell.col * CELL + 2, y: cell.row * CELL + 2,
            width: CELL - 4, height: CELL - 4,
            stroke: colour, class: 'owner-border',
          });
          layerOverlay.appendChild(border);
        }
      }
    }

    // Fortify count as a number badge (top-right corner of first cell)
    if (s.fortifyTokens > 0) {
      const fc = cells[0];
      const bx = fc.col * CELL + CELL - 10;
      const by = fc.row * CELL + 12;
      const bg = svgCreate('circle', { cx: bx, cy: by, r: 8, class: 'fortify-badge fortify-badge-bg' });
      layerOverlay.appendChild(bg);
      const txt = svgCreate('text', {
        x: bx, y: by,
        'text-anchor': 'middle', 'dominant-baseline': 'central',
        class: 'fortify-badge fortify-badge-text',
      });
      txt.textContent = s.fortifyTokens;
      layerOverlay.appendChild(txt);
    }

    // Pending alliance marker at dog parks
    if (game && s.type === SPACE_TYPES.DOG_PARK && game.pendingAlliances.has(s.id)) {
      const initId = game.pendingAlliances.get(s.id);
      const initCfg = playerConfigs.find(c => c.id === initId);
      const fc = cells[0];
      const heart = svgCreate('text', {
        x: fc.col * CELL + CELL / 2, y: fc.row * CELL + 14,
        'text-anchor': 'middle', 'dominant-baseline': 'middle',
        fill: initCfg ? (COLOUR_HEX[initCfg.colour] || initCfg.colour) : '#e05080',
        'font-size': '14px',
      });
      heart.textContent = '\u2665';
      layerOverlay.appendChild(heart);
    }
  }
}

function updatePawns() {
  layerPawns.innerHTML = '';
  // Group players by position
  const byPos = {};
  for (const p of game.players) {
    if (!byPos[p.position]) byPos[p.position] = [];
    byPos[p.position].push(p);
  }
  const offsets = {
    1: [[0, 0]],
    2: [[-10, 0], [10, 0]],
    3: [[-10, -7], [10, -7], [0, 10]],
    4: [[-10, -7], [10, -7], [-10, 10], [10, 10]],
  };
  for (const [posId, players] of Object.entries(byPos)) {
    const pos = positions[posId];
    if (!pos) continue;
    const offs = offsets[players.length] || offsets[4];
    for (let i = 0; i < players.length; i++) {
      const cfg = playerConfigs.find(c => c.id === players[i].id);
      const ox = offs[i] ? offs[i][0] : 0;
      const oy = offs[i] ? offs[i][1] : 0;
      const cx = pos.x + ox, cy = pos.y + oy;
      const colour = cfg ? (COLOUR_HEX[cfg.colour] || cfg.colour) : '#fff';
      const pawn = svgCreate('circle', {
        cx, cy, r: 11,
        fill: colour,
        class: 'pawn',
      });
      layerPawns.appendChild(pawn);
      // Player initial letter inside the pawn
      const initial = cfg ? cfg.name.charAt(0).toUpperCase() : '?';
      const label = svgCreate('text', {
        x: cx, y: cy,
        'text-anchor': 'middle', 'dominant-baseline': 'central',
        class: 'pawn-label',
      });
      label.textContent = initial;
      layerPawns.appendChild(label);
    }
  }
}

function highlightSpaces(ids, cls = 'highlight') {
  layerHighlight.innerHTML = '';
  for (const id of ids) {
    const cells = spaceIdToCells[id];
    if (!cells) continue;
    for (const cell of cells) {
      const r = svgCreate('rect', {
        x: cell.col * CELL, y: cell.row * CELL,
        width: CELL, height: CELL,
        class: cls,
      });
      layerHighlight.appendChild(r);
    }
  }
}
function clearHighlights() { layerHighlight.innerHTML = ''; }

// SVG helpers
function svgCreate(tag, attrs = {}) {
  const el = document.createElementNS(SVG_NS, tag);
  for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);
  return el;
}
function svgG(id) {
  const g = document.createElementNS(SVG_NS, 'g');
  if (id) g.id = id;
  return g;
}

// ═══════════════════════════════════════════════════════════════════════
//  UI HELPERS
// ═══════════════════════════════════════════════════════════════════════

function updateSidebar() {
  if (!game) return;
  const cp = game.getCurrentPlayer();
  const cfg = playerConfigs.find(c => c.id === cp.id);
  const colHex = COLOUR_HEX[cfg.colour] || cfg.colour;

  // Turn info
  document.getElementById('turn-info').innerHTML = `
    <div class="stat-row"><span class="label">Round</span><span class="value">${game.turnNumber}</span></div>
    <div class="stat-row"><span class="label">Max turns</span><span class="value">${game.config.maxTurns}</span></div>
  `;

  // Allies list
  let alliesHtml = '';
  if (cp.allies.length > 0) {
    const allyNames = cp.allies.map(aid => {
      const ac = playerConfigs.find(c => c.id === aid);
      return ac ? ac.name : aid;
    }).join(', ');
    alliesHtml = `<div class="stat-row"><span class="label">Allies</span><span class="value" style="color:#e05080">${allyNames}</span></div>`;
  }

  // Current player stats
  document.getElementById('current-player-stats').innerHTML = `
    <div class="stat-row" style="color:${colHex};font-weight:bold;font-size:14px">${cfg.name} (${ARCHETYPES[cfg.archetype].name})</div>
    <div class="stat-row stat-water"><span class="label">Water</span><span class="value">${cp.water} / ${ARCHETYPES[cp.archetype].water}</span></div>
    <div class="stat-row stat-swagger"><span class="label">Swagger</span><span class="value">${cp.swagger}</span></div>
    <div class="stat-row stat-drive"><span class="label">Drive</span><span class="value">${cp.drive}</span></div>
    <div class="stat-row stat-grit"><span class="label">Grit</span><span class="value">${cp.grit}</span></div>
    <div class="stat-row stat-bond"><span class="label">Bond</span><span class="value">${cp.bond}</span></div>
    ${alliesHtml}
    <div class="stat-row"><span class="label">Position</span><span class="value">${cp.position}</span></div>
  `;

  // All players summary
  let html = '';
  for (const p of game.players) {
    const c = playerConfigs.find(c => c.id === p.id);
    const cHex = COLOUR_HEX[c.colour] || c.colour;
    const terr = board.getTerritoriesOwnedBy(p.id).length;
    const isCurrent = p.id === cp.id ? ' current' : '';
    const allyDots = p.allies.length > 0 ? ` \u2665${p.allies.length}` : '';
    html += `<div class="player-summary${isCurrent}">
      <span class="ps-dot" style="background:${cHex}"></span>
      <span class="ps-name">${c.name}</span>
      <span class="ps-terr">${terr} T${allyDots}</span>
    </div>`;
  }
  document.getElementById('all-players-summary').innerHTML = html;
}

function setPhase(text) {
  document.getElementById('phase-banner').textContent = text;
}

function addLogEntry(text, cls = '') {
  const div = document.createElement('div');
  div.className = 'log-entry' + (cls ? ' ' + cls : '');
  div.textContent = text;
  const log = document.getElementById('game-log');
  log.appendChild(div);
  log.scrollTop = log.scrollHeight;
}

function showDice(d1, d2, total) {
  const dd = document.getElementById('dice-display');
  document.getElementById('die1').textContent = d1;
  document.getElementById('die2').textContent = d2;
  document.getElementById('die-total').textContent = total !== null ? total : '';
  dd.classList.add('visible');
}
function hideDice() {
  document.getElementById('dice-display').classList.remove('visible');
}

// Controls bar — dynamic buttons
function setControls(items) {
  const bar = document.getElementById('controls-bar');
  bar.innerHTML = '';
  for (const item of items) {
    if (item.type === 'info') {
      const span = document.createElement('span');
      span.className = 'ctrl-info';
      span.textContent = item.text;
      bar.appendChild(span);
    } else if (item.type === 'spacer') {
      const span = document.createElement('span');
      span.className = 'ctrl-spacer';
      bar.appendChild(span);
    } else if (item.type === 'button') {
      const btn = document.createElement('button');
      btn.className = 'ctrl-btn' + (item.cls ? ' ' + item.cls : '');
      btn.textContent = item.text;
      btn.addEventListener('click', () => {
        if (_resolveControlBtn) { _resolveControlBtn(item.value); _resolveControlBtn = null; }
      });
      bar.appendChild(btn);
    }
  }
}
function clearControls() { document.getElementById('controls-bar').innerHTML = ''; }

// ═══════════════════════════════════════════════════════════════════════
//  INTERACTION PROMISES
// ═══════════════════════════════════════════════════════════════════════

function waitForSpaceClick(validIds) {
  return new Promise((resolve) => {
    _validSpaceIds = validIds;
    _resolveSpaceClick = resolve;
  });
}

function waitForControl() {
  return new Promise((resolve) => { _resolveControlBtn = resolve; });
}

function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

// ═══════════════════════════════════════════════════════════════════════
//  ACTION HELPERS
// ═══════════════════════════════════════════════════════════════════════

function getActionableSpaces(player) {
  const result = [];
  const currentId = player.position;
  const neighbors = board.getNeighbors(currentId);
  const allTargets = [currentId, ...neighbors.map(n => n.space.id)];
  const seen = new Set();

  for (const tid of allTargets) {
    if (seen.has(tid)) continue; seen.add(tid);
    const s = board.getSpace(tid);
    if (!s) continue;
    const actions = [];

    if (s.type === SPACE_TYPES.TERRITORY) {
      if (s.owner === null && game.canClaim(player.id, tid).ok)
        actions.push({ type: 'claim', targetId: tid, label: `Claim ${s.label}`, cost: 'W:2 Sw:1' });
      if (s.owner && s.owner !== player.id && game.canChallenge(player.id, tid).ok)
        actions.push({ type: 'challenge', targetId: tid, label: `Challenge ${s.label}`, cost: 'W:2 Dr:1' });
      if (s.owner === player.id && game.canFortify(player.id, tid).ok)
        actions.push({ type: 'fortify', targetId: tid, label: `Fortify ${s.label}`, cost: 'W:1 Gr:1' });
    }
    if (s.type === SPACE_TYPES.DOG_PARK && game.canAlly(player.id, tid).ok) {
      actions.push({ type: 'ally', targetId: tid, label: `Ally at ${s.label}`, cost: 'W:1 Bd:1' });
    }
    if (s.type === SPACE_TYPES.WATER_SOURCE && game.canDrink(player.id).ok) {
      actions.push({ type: 'drink', targetId: tid, label: 'Drink', cost: 'Dr:1' });
    }

    if (actions.length > 0) result.push({ spaceId: tid, actions });
  }

  // PATH shortcut at current position
  const curSpace = board.getSpace(currentId);
  if (curSpace && curSpace.type === SPACE_TYPES.PATH && curSpace.pathExit && player.drive >= 1) {
    let entry = result.find(r => r.spaceId === currentId);
    if (!entry) { entry = { spaceId: currentId, actions: [] }; result.push(entry); }
    entry.actions.push({ type: 'shortcut', targetId: currentId, label: `Shortcut \u2192 ${curSpace.pathExit}`, cost: 'Dr:1' });
  }

  // Break alliance actions (attached to current position)
  for (const alliedId of player.allies) {
    if (game.canBreakAlliance(player.id, alliedId).ok) {
      const allyCfg = playerConfigs.find(c => c.id === alliedId);
      const allyName = allyCfg ? allyCfg.name : alliedId;
      let entry = result.find(r => r.spaceId === currentId);
      if (!entry) { entry = { spaceId: currentId, actions: [] }; result.push(entry); }
      entry.actions.push({ type: 'breakAlliance', targetId: alliedId, label: `Break alliance with ${allyName}`, cost: 'W:1 Sw:1' });
    }
  }

  return result;
}

// ═══════════════════════════════════════════════════════════════════════
//  GAME LOOP
// ═══════════════════════════════════════════════════════════════════════

async function runGame() {
  await delay(300);
  while (!game.gameOver) {
    game.startRound();
    addLogEntry(`=== Round ${game.turnNumber} ===`, 'round');
    updateSidebar();

    do {
      const player = game.getCurrentPlayer();
      const cfg = getConfig(player.id);
      addLogEntry(`--- ${cfg.name}'s turn ---`, 'system');
      updateSidebar();

      // Phase 1: Territory Income
      setPhase(`${cfg.name} — Income`);
      game.applyTerritoryIncome(player.id);
      flushEngineLog();
      updateSidebar();
      await delay(cfg.isAI ? 300 : 600);

      // Phase 2: Roll and Move
      setPhase(`${cfg.name} — Roll`);
      const d1 = Game.rollD6(), d2 = Game.rollD6();
      const maxSteps = d1 + d2;
      showDice(d1, d2, maxSteps);
      addLogEntry(`${cfg.name} rolled ${d1}+${d2} = ${maxSteps}`, 'system');
      await delay(cfg.isAI ? 600 : 1200);
      hideDice();

      setPhase(`${cfg.name} — Move`);
      let path;
      if (cfg.isClaude) {
        // Claude goal-based movement: pick a goal, then BFS toward it
        if (!aiGoals[player.id]) {
          setPhase(`${cfg.name} — Thinking...`);
          try {
            aiGoals[player.id] = await claudePickGoal(player);
          } catch (err) {
            console.warn('claudePickGoal failed, falling back', err);
            addLogEntry(`  ${cfg.name}: goal pick failed (${err.message}), using algo`, 'system');
            aiGoals[player.id] = algoPickGoal(player);
          }
        }
        const goal = aiGoals[player.id];
        if (goal) {
          path = bfsTowardTarget(player, maxSteps, [goal.spaceId]);
        } else {
          path = aiComputePath(player, maxSteps);
        }
        for (let i = 1; i < path.length; i++) {
          await delay(250);
          player.position = path[i];
          updatePawns();
        }
        player.position = path[0];
      } else if (cfg.isAI) {
        // Algorithmic AI: score-based movement
        path = aiComputePath(player, maxSteps);
        for (let i = 1; i < path.length; i++) {
          await delay(250);
          player.position = path[i];
          updatePawns();
        }
        player.position = path[0];
      } else {
        path = await humanBuildPath(player, maxSteps);
      }

      const moveResult = game.movePlayer(player.id, path);
      flushEngineLog();
      updateOverlay();
      updatePawns();
      updateSidebar();

      // Process pass-through effects
      if (moveResult.success && moveResult.effects) {
        for (const eff of moveResult.effects) {
          if (eff.type === 'dogPark') {
            game.applyDogPark(player.id);
            addLogEntry(`${cfg.name} passed Dog Park: +1 Bond`, 'action');
            updateSidebar();
          }
          if (eff.type === 'compulsoryBond') {
            const res = game.compulsoryBondJoin(player.id, eff.dogParkSpaceId);
            if (res.success) {
              addLogEntry(`${cfg.name} compulsory bond at ${eff.dogParkSpaceId}`, 'action');
              if (res.cleared && res.cleared.length > 0) {
                addLogEntry(`  Friendship sacrifice: cleared ${res.cleared.join(', ')}`, 'action');
              }
            }
            updateOverlay(); updateSidebar();
          }
          if (eff.type === 'pathEntry') {
            addLogEntry(`${cfg.name} at path entry (shortcut to ${eff.exitSpaceId} available)`, 'system');
          }
          if (eff.type === 'chanceCard') addLogEntry(`${cfg.name} passed Chance Spot (deck not implemented)`, 'system');
          if (eff.type === 'eventsCard') addLogEntry(`${cfg.name} passed Events (deck not implemented)`, 'system');
        }
      }

      // Phase 3: Action
      setPhase(`${cfg.name} — Action`);
      if (cfg.isClaude) {
        // Check if we reached the goal (at it, or path walked through it)
        const goal = aiGoals[player.id];
        const reached = !goal || player.position === goal.spaceId || path.includes(goal.spaceId);
        if (reached) {
          aiGoals[player.id] = null; // clear goal, pick new one next turn
        }
        const available = getActionableSpaces(player);
        if (available.flatMap(a => a.actions).length > 0) {
          if (reached) {
            // At goal: let Claude decide
            setPhase(`${cfg.name} — Thinking...`);
            try {
              await claudePickAction(player, cfg, available);
            } catch (err) {
              addLogEntry(`  ${cfg.name}: Claude action error, falling back. (${err.message})`, 'system');
              await aiDoAction(player, cfg);
            }
          } else {
            // En route: take opportunistic actions via algorithmic AI
            await aiDoAction(player, cfg);
          }
        }
      } else if (cfg.isAI) {
        await aiDoAction(player, cfg);
      } else {
        await humanDoAction(player, cfg);
      }
      clearControls();
      updateOverlay(); updatePawns(); updateSidebar();

      // Phase 4: Home Resupply — check if player ended on a sidewalk
      // adjacent to their own home (HOME spaces aren't walkable, so we
      // must check neighbors of the final position, not the path itself)
      {
        const homeSpace = board.getHomeSpace(player.id, game.players);
        if (homeSpace) {
          const atHome = board.getNeighbors(player.position)
            .some(n => n.space.id === homeSpace.id);
          if (atHome) {
            game.applyHomeResupply(player.id);
            addLogEntry(`${cfg.name} resupplied at home`, 'action');
            updateSidebar();
          }
        }
      }

      // Phase 5: Win check
      const win = game.checkWinConditions();
      updateSidebar();
      if (win.gameOver) break;

      await delay(200);
    } while (game.advancePlayer());
  }

  showGameOver();
}

// ═══════════════════════════════════════════════════════════════════════
//  HUMAN INTERACTION
// ═══════════════════════════════════════════════════════════════════════

async function humanBuildPath(player, maxSteps) {
  const path = [player.position];
  let stepsLeft = maxSteps;
  let accDriveCost = 0;

  while (stepsLeft > 0) {
    const current = path[path.length - 1];
    const WALKABLE = ['sidewalk', 'intersection', 'sideStreet', 'path'];
    const reachable = board.getNeighbors(current).filter(n =>
      WALKABLE.includes(n.space.type) && !path.includes(n.space.id) && (accDriveCost + n.driveCost) <= player.drive
    );
    if (reachable.length === 0) break;

    // Only allow ending move early at home turf or dog park
    const allowEnd = path.length > 1 && canStopEarly(player.id, current);

    highlightSpaces(reachable.map(n => n.space.id));
    setControls([
      { type: 'info', text: `Steps: ${stepsLeft} | Drive: ${player.drive - accDriveCost}` },
      { type: 'spacer' },
      allowEnd ? { type: 'button', text: 'End Move (at home/park)', value: 'end', cls: 'primary' } : null,
      path.length > 1 ? { type: 'button', text: 'Undo', value: 'undo', cls: 'warn' } : null,
    ].filter(Boolean));

    // Wait for either a space click or a control button
    const result = await Promise.race([
      waitForSpaceClick(reachable.map(n => n.space.id)).then(id => ({ type: 'space', id })),
      waitForControl().then(val => ({ type: 'ctrl', val })),
    ]);

    // Clear stale resolvers
    _resolveSpaceClick = null; _validSpaceIds = null; _resolveControlBtn = null;

    if (result.type === 'ctrl' && result.val === 'end') break;
    if (result.type === 'ctrl' && result.val === 'undo') {
      if (path.length > 1) {
        const removed = path.pop();
        const edge = board.getNeighbors(path[path.length - 1]).find(n => n.space.id === removed);
        if (edge) accDriveCost -= edge.driveCost;
        stepsLeft += 1;
        // Visual update
        player.position = path[path.length - 1];
        updatePawns();
      }
      continue;
    }
    if (result.type === 'space') {
      const edge = reachable.find(n => n.space.id === result.id);
      if (edge) {
        path.push(result.id);
        accDriveCost += edge.driveCost;
        stepsLeft -= 1;
        // Visual: move pawn as path builds
        player.position = result.id;
        updatePawns();
      }
    }
  }

  clearHighlights();
  clearControls();
  // Reset position so movePlayer can set it
  player.position = path[0];
  return path;
}

async function humanDoAction(player, cfg) {
  const actionable = getActionableSpaces(player);
  if (actionable.length === 0) {
    addLogEntry(`${cfg.name} has no available actions — passing.`, 'system');
    return;
  }

  // Show actionable spaces and controls
  const allIds = actionable.map(a => a.spaceId);
  highlightSpaces(allIds, 'highlight-action');

  while (true) {
    setControls([
      { type: 'info', text: 'Click a highlighted space or pass' },
      { type: 'spacer' },
      { type: 'button', text: 'Pass', value: 'pass', cls: '' },
    ]);

    const result = await Promise.race([
      waitForSpaceClick(allIds).then(id => ({ type: 'space', id })),
      waitForControl().then(val => ({ type: 'ctrl', val })),
    ]);
    _resolveSpaceClick = null; _validSpaceIds = null; _resolveControlBtn = null;

    if (result.type === 'ctrl' && result.val === 'pass') {
      addLogEntry(`${cfg.name} passes.`, 'system');
      break;
    }

    if (result.type === 'space') {
      const entry = actionable.find(a => a.spaceId === result.id);
      if (!entry) continue;

      // Show action buttons for this space
      const btns = entry.actions.map((a, i) => ({
        type: 'button', text: `${a.label} (${a.cost})`, value: String(i), cls: 'primary',
      }));
      btns.push({ type: 'spacer' });
      btns.push({ type: 'button', text: 'Back', value: 'back', cls: '' });
      setControls(btns);

      const actionResult = await waitForControl();
      _resolveControlBtn = null;

      if (actionResult === 'back') continue;

      const actionIdx = parseInt(actionResult);
      if (isNaN(actionIdx) || !entry.actions[actionIdx]) continue;

      const action = entry.actions[actionIdx];
      await executeAction(player, cfg, action);
      break;
    }
  }

  clearHighlights();
}

async function executeAction(player, cfg, action) {
  switch (action.type) {
    case 'claim': {
      game.claim(player.id, action.targetId);
      addLogEntry(`${cfg.name} claimed ${action.targetId}`, 'action');
      break;
    }
    case 'challenge': {
      await doChallenge(player, cfg, action.targetId);
      break;
    }
    case 'fortify': {
      game.fortify(player.id, action.targetId);
      addLogEntry(`${cfg.name} fortified ${action.targetId}`, 'action');
      break;
    }
    case 'ally': {
      game.ally(player.id, action.targetId);
      addLogEntry(`${cfg.name} initiated alliance at ${action.targetId}`, 'action');
      break;
    }
    case 'breakAlliance': {
      const allyCfg = getConfig(action.targetId);
      const allyName = allyCfg ? allyCfg.name : action.targetId;
      game.breakAlliance(player.id, action.targetId);
      addLogEntry(`${cfg.name} broke alliance with ${allyName}`, 'action');
      break;
    }
    case 'shortcut': {
      const res = game.takeShortcut(player.id, action.targetId);
      if (res.success) {
        addLogEntry(`${cfg.name} took shortcut \u2192 ${res.exitSpaceId}`, 'action');
      }
      break;
    }
    case 'drink': {
      const waterGain = 99; // tops up to archetype max
      game.drink(player.id, waterGain);
      addLogEntry(`${cfg.name} drank — water refilled`, 'action');
      break;
    }
  }
  flushEngineLog();
  updateOverlay(); updatePawns(); updateSidebar();
}

async function doChallenge(player, cfg, targetId) {
  const space = board.getSpace(targetId);
  const defId = space.owner;
  const defCfg = getConfig(defId);

  const payResult = game.payChallengeCost(player.id, targetId);
  if (!payResult.success) {
    addLogEntry(`Challenge failed: ${payResult.reason}`, 'challenge');
    return;
  }

  addLogEntry(`${cfg.name} challenges ${defCfg.name} at ${targetId}!`, 'challenge');
  updateSidebar();
  await delay(600);

  let result;
  do {
    const aRoll = Game.rollD6(), dRoll = Game.rollD6();
    showDice(aRoll, dRoll, null);
    await delay(900);
    hideDice();

    result = game.resolveChallenge(player.id, defId, targetId, aRoll, dRoll);
    addLogEntry(
      `  Attack ${result.attackRoll} \u2192 ${result.attackTotal}  vs  Defense ${result.defendRoll} \u2192 ${result.defendTotal}` +
      (result.fortifyBonus ? ` (+${result.fortifyBonus} fortify)` : '') +
      (result.clusterRule ? ' [cluster]' : ''),
      'challenge'
    );

    if (result.outcome === 'tie') {
      addLogEntry('  Tie! Re-rolling...', 'challenge');
      await delay(800);
    }
  } while (result.outcome === 'tie');

  if (result.outcome === 'attackerWins') {
    addLogEntry(`  ${cfg.name} wins!`, 'challenge');
    updateOverlay();

    // Re-claim choice
    const rc = game.canReClaim(player.id);
    if (rc.ok) {
      let useResource;
      if (cfg.isAI) {
        useResource = player.swagger >= 1 ? 'swagger' : (player.grit >= 1 ? 'grit' : null);
      } else {
        // Show re-claim choice
        const btns = [];
        if (player.swagger >= 1) btns.push({ type: 'button', text: 'Re-claim (Swagger)', value: 'swagger', cls: 'primary' });
        if (player.grit >= 1)    btns.push({ type: 'button', text: 'Re-claim (Grit)', value: 'grit', cls: 'primary' });
        btns.push({ type: 'spacer' });
        btns.push({ type: 'button', text: 'Decline', value: 'decline', cls: 'warn' });
        setControls(btns);
        useResource = await waitForControl();
        _resolveControlBtn = null;
        if (useResource === 'decline') useResource = null;
      }

      if (useResource) {
        game.reClaim(player.id, targetId, useResource);
        addLogEntry(`  ${cfg.name} re-claimed with ${useResource}`, 'action');
      } else {
        game.declineReClaim(targetId);
        addLogEntry(`  ${cfg.name} declined re-claim`, 'system');
      }
    } else {
      game.declineReClaim(targetId);
      addLogEntry(`  Cannot re-claim (no swagger or grit)`, 'system');
    }
  } else {
    addLogEntry(`  ${defCfg.name} defends!`, 'challenge');
  }

  flushEngineLog();
  updateOverlay(); updatePawns(); updateSidebar();
}

// ═══════════════════════════════════════════════════════════════════════
//  CLAUDE AI PLAYER
// ═══════════════════════════════════════════════════════════════════════

// ── BFS distances from a start space (walkable spaces only) ──

function bfsDistances(startId) {
  const dist = {};
  dist[startId] = 0;
  const queue = [startId];
  while (queue.length > 0) {
    const cur = queue.shift();
    const d = dist[cur];
    for (const n of board.getNeighbors(cur)) {
      if (dist[n.space.id] !== undefined) continue;
      // Record distance to ALL neighbors (so territories/homes get a distance)
      dist[n.space.id] = d + 1;
      // But only continue traversal through walkable spaces
      if (WALKABLE.includes(n.space.type)) {
        queue.push(n.space.id);
      }
    }
  }
  return dist;
}

// ── Claude goal-picking: asks Claude WHERE to go, algo handles HOW ──

const aiGoals = {};  // playerId → { type, spaceId } or null

async function claudePickGoal(player) {
  const arch = ARCHETYPES[player.archetype];
  const myName = getConfig(player.id).name;
  const myTerritories = board.getTerritoriesOwnedBy(player.id);

  // Build candidate destinations with sidewalk IDs resolved
  const candidates = [];

  // Home turf
  const homeAdjacentSidewalks = board.getNeighbors(
    board.getHomeSpace(player.id, game.players).id
  ).filter(n => WALKABLE.includes(n.space.type));
  if (homeAdjacentSidewalks.length > 0) {
    candidates.push({
      label: `go home (full resupply: W:${arch.water} Sw:${arch.swagger} Dr:${arch.drive} Gr:${arch.grit} Bd:${arch.bond})`,
      type: 'home',
      spaceId: homeAdjacentSidewalks[0].space.id
    });
  }

  // Water sources
  for (const ws of board.getSpacesByType(SPACE_TYPES.WATER_SOURCE)) {
    const adj = board.getNeighbors(ws.id).filter(n => WALKABLE.includes(n.space.type));
    if (adj.length > 0) {
      candidates.push({
        label: `drink at ${ws.id} (restores water to ${arch.water} only, costs 1 drive)`,
        type: 'water',
        spaceId: adj[0].space.id
      });
    }
  }

  // Unclaimed territories (closest 6)
  const dists = bfsDistances(player.position);
  const unclaimed = board.getAllSpaces()
    .filter(s => s.type === SPACE_TYPES.TERRITORY && s.owner === null)
    .map(s => {
      const adj = board.getNeighbors(s.id).filter(n => WALKABLE.includes(n.space.type));
      const sidewalkId = adj[0]?.space.id;
      const dist = sidewalkId ? (dists[sidewalkId] ?? 999) : 999;
      return { s, sidewalkId, dist };
    })
    .filter(x => x.sidewalkId)
    .sort((a, b) => a.dist - b.dist)
    .slice(0, 6);

  for (const { s, sidewalkId, dist } of unclaimed) {
    candidates.push({
      label: `claim ${s.id} (empty territory, ~${dist} steps away)`,
      type: 'territory',
      spaceId: sidewalkId
    });
  }

  // Opponent territories (closest 4, unfortified preferred)
  const opponent = board.getAllSpaces()
    .filter(s => s.type === SPACE_TYPES.TERRITORY && s.owner && s.owner !== player.id)
    .map(s => {
      const adj = board.getNeighbors(s.id).filter(n => WALKABLE.includes(n.space.type));
      const sidewalkId = adj[0]?.space.id;
      const dist = sidewalkId ? (dists[sidewalkId] ?? 999) : 999;
      const ownerCfg = getConfig(s.owner);
      return { s, sidewalkId, dist, ownerCfg };
    })
    .filter(x => x.sidewalkId)
    .sort((a, b) => a.dist - b.dist)
    .slice(0, 4);

  for (const { s, sidewalkId, dist, ownerCfg } of opponent) {
    candidates.push({
      label: `challenge ${s.id} (owned by ${ownerCfg.name}${s.fortifyTokens ? ', fortified' : ', unfortified'}, ~${dist} steps away)`,
      type: 'territory',
      spaceId: sidewalkId
    });
  }

  // Dog parks
  for (const dp of board.getSpacesByType(SPACE_TYPES.DOG_PARK)) {
    const adj = board.getNeighbors(dp.id).filter(n => WALKABLE.includes(n.space.type));
    if (adj.length > 0) {
      const hasBond = game.pendingAlliances.has(dp.id);
      candidates.push({
        label: `go to dog park ${dp.id} (${hasBond ? 'active bond — compulsory join costs 1 water' : 'initiate alliance costs 1 water + 1 bond'})`,
        type: 'dogpark',
        spaceId: adj[0].space.id
      });
    }
  }

  if (candidates.length === 0) throw new Error('No candidates');

  const otherPlayers = game.players
    .filter(p => p.id !== player.id)
    .map(p => {
      const cfg = getConfig(p.id);
      const tc = board.getTerritoriesOwnedBy(p.id).length;
      return `  ${cfg.name}: ${tc} territories, W:${p.water} Sw:${p.swagger} Dr:${p.drive} Gr:${p.grit}`;
    }).join('\n');

  const prompt = `You are playing Uri-Nation, a territory control board game. Choose your next destination.

WIN CONDITION: First to 15 territories wins. After 30 rounds, most territories wins.

TURN STRUCTURE (every turn):
1. Territory income: +1 swagger per 3 connected territories you own.
2. Roll 2d6 and move along sidewalks. Must use full roll (can only stop early at home or dog park).
3. Action phase: take ONE action at your stopping position (claim, challenge, fortify, ally, drink).
4. Home resupply: if you ended on your home sidewalk, ALL resources restore to max automatically.

KEY COSTS:
- Claim empty territory: 2 water + 1 swagger. NO swagger = CANNOT claim.
- Challenge opponent territory: 2 water + 1 drive. Both roll 1d6, attacker must roll higher. Defender gets +1 if fortified. If you win, you still need 1 swagger OR 1 grit to convert the territory.
- Fortify your territory: 1 water + 1 grit. Adds +1 to defender's roll (max 1 per territory).
- Drink at water source: 1 drive. Restores water ONLY — not swagger, drive, grit, or bond.
- Alliance at dog park: 1 water + 1 bond. Protects home neighbourhoods from allied players.

RESOURCE STRATEGY:
- Home turf restores ALL resources (water, swagger, drive, grit, bond) to your archetype max.
- Water sources restore WATER ONLY. If you need swagger or drive, go home instead.
- You get an action BEFORE home resupply — so you can claim a territory near home and still resupply.
- It may take multiple turns to reach a distant destination. You will take opportunistic actions along the way.

YOUR STATE:
- ${myName} (${player.archetype}): ${myTerritories.length} territories
- Resources: W:${player.water}/${arch.water} Sw:${player.swagger} Dr:${player.drive} Gr:${player.grit} Bd:${player.bond}
- Round: ${game.turnNumber}/30

OTHER PLAYERS:
${otherPlayers}

DESTINATIONS:
${candidates.map((c, i) => `  ${i + 1}. ${c.label}`).join('\n')}

Pick the destination that best advances your position. If swagger = 0 and grit = 0, go home. Respond JSON only:
{
  "choice": <number>,
  "reasoning": "one sentence why"
}`;

  const apiKey = sessionStorage.getItem('anthropic_api_key');
  if (!apiKey) throw new Error('No API key configured');

  const resp = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': apiKey,
      'anthropic-version': '2023-06-01',
      'anthropic-dangerous-direct-browser-access': 'true',
    },
    body: JSON.stringify({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 200,
      messages: [{ role: 'user', content: prompt }],
    }),
  });

  if (!resp.ok) {
    const errText = await resp.text().catch(() => '');
    throw new Error(`API ${resp.status}: ${errText.slice(0, 200)}`);
  }
  const data = await resp.json();
  const raw = (data.content.find(b => b.type === 'text')?.text) || '';
  const start = raw.indexOf('{');
  const end = raw.lastIndexOf('}');
  if (start === -1 || end === -1) throw new Error('No JSON found in response');
  const json = JSON.parse(raw.slice(start, end + 1));

  const chosen = candidates[json.choice - 1];
  if (!chosen) throw new Error('Invalid choice index: ' + json.choice);

  // Log the reasoning
  const myNameForLog = getConfig(player.id).name;
  addLogEntry(`[goal] ${myNameForLog} → ${chosen.label} — ${json.reasoning}`, 'reasoning');
  game._log(player.id, `[goal] ${chosen.label} — ${json.reasoning}`);

  return { type: chosen.type, spaceId: chosen.spaceId };
}

// ── Algorithmic goal fallback (mirrors scoreWalkableDest priorities) ──

function algoPickGoal(player) {
  const arch = ARCHETYPES[player.archetype];
  const dists = bfsDistances(player.position);

  // If we can't claim or challenge, go home
  if (player.swagger === 0 && player.grit === 0 && player.water < 2) {
    const homeSidewalks = getHomeSidewalks(player);
    if (homeSidewalks.length > 0) return { type: 'home', spaceId: homeSidewalks[0] };
  }

  // If very low water, go home
  if (player.water < 2 && player.swagger === 0) {
    const homeSidewalks = getHomeSidewalks(player);
    if (homeSidewalks.length > 0) return { type: 'home', spaceId: homeSidewalks[0] };
  }

  // Find closest unclaimed territory we can afford to claim
  if (player.water >= 2 && player.swagger >= 1) {
    const unclaimed = board.getAllSpaces()
      .filter(s => s.type === SPACE_TYPES.TERRITORY && s.owner === null)
      .map(s => {
        const adj = board.getNeighbors(s.id).filter(n => WALKABLE.includes(n.space.type));
        const sidewalkId = adj[0]?.space.id;
        const dist = sidewalkId ? (dists[sidewalkId] ?? 999) : 999;
        return { sidewalkId, dist };
      })
      .filter(x => x.sidewalkId)
      .sort((a, b) => a.dist - b.dist);
    if (unclaimed.length > 0) return { type: 'territory', spaceId: unclaimed[0].sidewalkId };
  }

  // Default: go home
  const homeSidewalks = getHomeSidewalks(player);
  if (homeSidewalks.length > 0) return { type: 'home', spaceId: homeSidewalks[0] };

  return null;
}

// ── Claude action-only decision (movement handled by algorithmic AI) ──

async function claudePickAction(player, cfg, available) {
  const arch = ARCHETYPES[player.archetype];
  const myName = cfg.name;
  const myTerritories = board.getTerritoriesOwnedBy(player.id).length;

  // Check if player is at home (resupply will happen after this action)
  const homeSpace = board.getHomeSpace(player.id, game.players);
  const atHome = homeSpace && board.getNeighbors(player.position)
    .some(n => n.space.id === homeSpace.id);

  const allActions = available.flatMap(a => a.actions);
  const options = allActions.map(a => {
    const target = board.getSpace(a.targetId);
    const ownerCfg = target?.owner ? getConfig(target.owner) : null;
    let desc = `${a.type} \u2192 ${a.targetId}`;
    if (a.type === 'claim') desc += ` (empty territory)`;
    if (a.type === 'challenge') desc += ` (owned by ${ownerCfg?.name}, ${target?.fortifyTokens ? 'fortified' : 'unfortified'})`;
    if (a.type === 'fortify') desc += ` (your territory, adds +1 defence)`;
    if (a.type === 'ally') desc += ` (dog park, protects home neighbourhoods)`;
    if (a.type === 'drink') desc += ` (water source, refills water to ${arch.water})`;
    if (a.type === 'shortcut') desc += ` (path shortcut)`;
    if (a.type === 'breakAlliance') desc += ` (break alliance)`;
    return desc;
  }).join('\n');

  const otherPlayers = game.players
    .filter(p => p.id !== player.id)
    .map(p => {
      const pcfg = getConfig(p.id);
      const tc = board.getTerritoriesOwnedBy(p.id).length;
      return `  ${pcfg.name}: ${tc} territories, W:${p.water} Sw:${p.swagger} Dr:${p.drive} Gr:${p.grit}`;
    }).join('\n');

  const prompt = `You are playing Uri-Nation. Pick the best action from what's available.

WIN CONDITION: First to 15 territories wins. After 30 rounds, most territories wins.

ACTION RULES:
- claim: 2 water + 1 swagger → place your mark on an empty territory. Expand your holdings.
- challenge: 2 water + 1 drive → contest an opponent's territory. Both roll 1d6 — you must roll HIGHER than the defender. Defender gets +1 if fortified. 3+ connected territories = ties go to defender (cluster rule). If you win, you must spend 1 swagger OR 1 grit to convert it; otherwise territory goes empty.
- fortify: 1 water + 1 grit → add +1 defence to your own territory (max 1 per territory). Makes challenges harder for opponents.
- ally: 1 water + 1 bond → initiate alliance at dog park. Bonded players cannot challenge each other's home neighbourhood territories.
- drink: 1 drive → refill water to your max (${arch.water}). Does NOT restore swagger, drive, grit, or bond.
- none: skip action this turn.

CONTEXT: ${atHome ? 'You ARE at your home sidewalk — ALL resources will restore to max AFTER this action. Spend freely!' : 'You are NOT at home. Resources you spend now are gone until you visit home.'}

YOUR STATE:
- ${myName} (${player.archetype}): ${myTerritories} territories
- Resources: W:${player.water}/${arch.water} Sw:${player.swagger} Dr:${player.drive} Gr:${player.grit} Bd:${player.bond}
- Round: ${game.turnNumber}/30

OTHER PLAYERS:
${otherPlayers}

AVAILABLE ACTIONS (you can afford all of these):
${options}

Which action best advances your position? Respond JSON only:
{
  "action": "claim|challenge|fortify|ally|drink|none",
  "actionTarget": "space id or null",
  "reasoning": "one sentence why"
}`;

  const apiKey = sessionStorage.getItem('anthropic_api_key');
  if (!apiKey) throw new Error('No API key configured');

  const resp = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': apiKey,
      'anthropic-version': '2023-06-01',
      'anthropic-dangerous-direct-browser-access': 'true',
    },
    body: JSON.stringify({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 300,
      messages: [{ role: 'user', content: prompt }],
    }),
  });

  if (!resp.ok) {
    const errText = await resp.text().catch(() => '');
    throw new Error(`API ${resp.status}: ${errText.slice(0, 200)}`);
  }
  const data = await resp.json();
  const raw = (data.content.find(b => b.type === 'text')?.text) || '';
  const start = raw.indexOf('{');
  const end = raw.lastIndexOf('}');
  if (start === -1 || end === -1) throw new Error('No JSON found in response');
  const response = JSON.parse(raw.slice(start, end + 1));

  // Log reasoning
  if (response.reasoning) {
    addLogEntry(`  ${cfg.name} thinks: "${response.reasoning}"`, 'reasoning');
    game._log(player.id, `[reasoning] ${response.reasoning}`);
  }

  const { action, actionTarget } = response;
  if (!action || action === 'pass' || action === 'none') {
    addLogEntry(`${cfg.name} (Claude AI): passes.`, 'system');
    return;
  }

  // Find matching action
  let matched = null;
  if (actionTarget) {
    matched = allActions.find(a => a.type === action && a.targetId === actionTarget);
  }
  if (!matched) {
    matched = allActions.find(a => a.type === action);
  }

  if (matched) {
    await executeAction(player, cfg, matched);
  } else {
    addLogEntry(`  ${cfg.name}: "${action} ${actionTarget || ''}" not available here, skipping.`, 'system');
  }
}

// ═══════════════════════════════════════════════════════════════════════
//  AI PLAYER — ALGORITHMIC FALLBACK (goal-directed, priority-driven)
// ═══════════════════════════════════════════════════════════════════════

const WALKABLE = ['sidewalk', 'intersection', 'sideStreet', 'path'];

// A player can only stop early (before using full roll) at spaces adjacent
// to their own home turf or a dog park.  All other stops require full roll.
function canStopEarly(playerId, spaceId) {
  for (const n of board.getNeighbors(spaceId)) {
    if (n.space.type === SPACE_TYPES.DOG_PARK) return true;
    if (n.space.type === SPACE_TYPES.HOME) {
      const player = game.players.find(p => p.id === playerId);
      const homeSpace = board.getHomeSpace(playerId, game.players);
      if (homeSpace && homeSpace.id === n.space.id) return true;
    }
  }
  return false;
}

const aiStuckTurns = {};   // playerId → consecutive turns stuck with no action
const aiLastPosition = {}; // playerId → position last turn

// ── BFS within movement range (walkable spaces only) ──

function bfsReachable(player, maxSteps) {
  const reachable = new Map();
  const queue = [[player.position, 0, 0, null]];
  reachable.set(player.position, { steps: 0, driveCost: 0, parent: null });

  while (queue.length > 0) {
    const [curId, steps, drCost] = queue.shift();
    if (steps >= maxSteps) continue;

    for (const n of board.getNeighbors(curId)) {
      if (!WALKABLE.includes(n.space.type)) continue;
      const nId = n.space.id;
      const newDrive = drCost + n.driveCost;
      if (newDrive > player.drive) continue;
      const newSteps = steps + 1;
      const existing = reachable.get(nId);
      if (!existing || newSteps < existing.steps || (newSteps === existing.steps && newDrive < existing.driveCost)) {
        reachable.set(nId, { steps: newSteps, driveCost: newDrive, parent: curId });
        queue.push([nId, newSteps, newDrive, curId]);
      }
    }
  }
  return reachable;
}

function reconstructPath(reachable, targetId) {
  const path = [];
  let cur = targetId;
  while (cur !== null) {
    path.unshift(cur);
    const info = reachable.get(cur);
    if (!info) break;
    cur = info.parent;
  }
  return path;
}

// ── Find the walkable sidewalk(s) adjacent to a player's home ──

function getHomeSidewalks(player) {
  const homeSpace = board.getHomeSpace(player.id, game.players);
  if (!homeSpace) return [];
  return board.getNeighbors(homeSpace.id)
    .filter(n => WALKABLE.includes(n.space.type))
    .map(n => n.space.id);
}

// ── BFS shortest path toward a target space (across full board, walkable only) ──

function bfsTowardTarget(player, maxSteps, targetIds) {
  const reachable = bfsReachable(player, maxSteps);
  const valid = getValidDestinations(player.id, reachable, maxSteps);

  // Find the valid destination that is closest to any targetId
  let bestDest = null;
  let bestDist = Infinity;

  for (const [destId] of valid) {
    if (destId === player.position) continue;
    if (targetIds.includes(destId)) {
      // We can reach the target directly
      return reconstructPath(reachable, destId);
    }
    // BFS from destId toward targets (full graph)
    const visited = new Set([destId]);
    const queue = [[destId, 0]];
    while (queue.length > 0) {
      const [cur, d] = queue.shift();
      if (d >= bestDist) break; // Can't improve
      if (targetIds.includes(cur)) {
        bestDist = d;
        bestDest = destId;
        break;
      }
      for (const nb of board.getNeighbors(cur)) {
        if (!visited.has(nb.space.id)) {
          visited.add(nb.space.id);
          queue.push([nb.space.id, d + 1]);
        }
      }
    }
  }

  if (bestDest) {
    const path = reconstructPath(reachable, bestDest);
    if (path.length > 0 && path[0] === player.position) return path;
  }

  // Fallback: no valid destination found toward target. Pick the farthest
  // reachable space (any, not just valid-stop) in the direction of the target
  // so the player never stands still.
  let fallbackDest = null;
  let fallbackDist = Infinity;
  for (const [destId] of reachable) {
    if (destId === player.position) continue;
    // Quick BFS distance from destId to any target
    const visited2 = new Set([destId]);
    const queue2 = [[destId, 0]];
    while (queue2.length > 0) {
      const [cur2, d2] = queue2.shift();
      if (d2 >= fallbackDist) break;
      if (targetIds.includes(cur2)) {
        fallbackDist = d2;
        fallbackDest = destId;
        break;
      }
      for (const nb2 of board.getNeighbors(cur2)) {
        if (!visited2.has(nb2.space.id)) {
          visited2.add(nb2.space.id);
          queue2.push([nb2.space.id, d2 + 1]);
        }
      }
    }
  }
  if (fallbackDest) {
    const path = reconstructPath(reachable, fallbackDest);
    if (path.length > 0 && path[0] === player.position) return path;
  }

  return [player.position];
}

// ── Score a walkable destination by what's adjacent to it ──

function scoreWalkableDest(player, destId, steps) {
  const arch = ARCHETYPES[player.archetype];
  const neighbors = board.getNeighbors(destId);
  let score = 0;

  // Penalty for staying put — prefer moving somewhere new
  if (destId === player.position) score -= 8;

  for (const n of neighbors) {
    const s = n.space;
    if (s.type === SPACE_TYPES.TERRITORY) {
      if (s.owner === null) {
        // Unclaimed territory — high priority if we can claim
        if (player.water >= 2 && player.swagger >= 1) score += 10;
        else score += 2; // Still worth moving near for later
      } else if (s.owner !== player.id && !player.allies.includes(s.owner)) {
        // Opponent territory — worth challenging if affordable
        if (player.water >= 2 && player.drive >= 1) score += 5;
        else score += 1;
      } else if (s.owner === player.id && s.fortifyTokens < game.config.maxFortify) {
        // Own territory, can fortify
        if (player.water >= 1 && player.grit >= 1) score += 3;
      }
    }
    if (s.type === SPACE_TYPES.WATER_SOURCE && player.water < arch.water) {
      // Water source — urgent if low water
      if (player.water <= 1) score += 15;
      else if (player.water <= Math.ceil(arch.water / 2)) score += 8;
      else score += 2;
    }
    if (s.type === SPACE_TYPES.HOME && s.playerColour === player.colour) {
      // Own home — resupply value (high when any resource is depleted)
      const needsHome = player.swagger === 0 || player.water < 2 || player.drive === 0;
      if (needsHome) score += 20;
      else {
        const deficit = (arch.water - player.water) + (arch.swagger - player.swagger) +
                        (arch.drive - player.drive);
        if (deficit >= 3) score += 6;
        else score += 1;
      }
    }
    if (s.type === SPACE_TYPES.DOG_PARK) {
      if (player.water >= 1 && player.bond >= 1) score += 2;
    }
  }

  // Slight distance penalty to prefer closer goals
  score -= steps * 0.2;
  return score;
}

// ── Valid destinations: full roll OR early stop at home/dog park ──

function getValidDestinations(playerId, reachable, maxSteps) {
  const valid = new Map();
  for (const [destId, info] of reachable) {
    if (info.steps === maxSteps || canStopEarly(playerId, destId)) {
      valid.set(destId, info);
    }
  }
  return valid;
}

// ── Goal-directed AI movement ──

function aiComputePath(player, maxSteps) {
  // Stuck escape: if stuck for 2+ turns, force movement toward home
  const stuck = aiStuckTurns[player.id] || 0;
  if (stuck >= 2) {
    const homeSidewalks = getHomeSidewalks(player);
    if (homeSidewalks.length > 0) {
      return bfsTowardTarget(player, maxSteps, homeSidewalks);
    }
  }

  const reachable = bfsReachable(player, maxSteps);
  const valid = getValidDestinations(player.id, reachable, maxSteps);

  let bestScore = -Infinity;
  let bestDest = player.position;

  for (const [destId, info] of valid) {
    const score = scoreWalkableDest(player, destId, info.steps);
    if (score > bestScore) {
      bestScore = score;
      bestDest = destId;
    }
  }

  // If nothing scored well, move toward home sidewalk
  if (bestScore <= 0) {
    const homeSidewalks = getHomeSidewalks(player);
    if (homeSidewalks.length > 0) {
      return bfsTowardTarget(player, maxSteps, homeSidewalks);
    }
  }

  // Last resort: if best is still current position, pick any reachable space
  // that isn't the current position so the player always moves their full roll
  if (bestDest === player.position) {
    for (const [destId] of valid) {
      if (destId !== player.position) { bestDest = destId; break; }
    }
  }
  if (bestDest === player.position) {
    // Even valid is empty/only current — grab any reachable space
    for (const [destId] of reachable) {
      if (destId !== player.position) { bestDest = destId; break; }
    }
  }
  if (bestDest === player.position) return [player.position];

  const path = reconstructPath(reachable, bestDest);
  if (path.length === 0 || path[0] !== player.position) return [player.position];
  return path;
}

// ── Priority-driven AI action selection ──

async function aiDoAction(player, cfg) {
  await delay(400);

  // Track stuck state — detect position change
  const prevPos = aiLastPosition[player.id];
  if (player.position !== prevPos) {
    aiStuckTurns[player.id] = 0;
  }
  aiLastPosition[player.id] = player.position;

  const actionable = getActionableSpaces(player);
  const allActions = actionable.flatMap(a => a.actions);
  if (allActions.length === 0) {
    addLogEntry(`${cfg.name} (AI): no actions available.`, 'system');
    aiStuckTurns[player.id] = (aiStuckTurns[player.id] || 0) + 1;
    return;
  }

  const arch = ARCHETYPES[player.archetype];

  // Priority 1: Drink if water below max and a drink action is available
  if (player.water < arch.water) {
    const drink = allActions.find(a => a.type === 'drink');
    if (drink) { await executeAction(player, cfg, drink); aiStuckTurns[player.id] = 0; return; }
  }

  // Priority 2: Claim any available territory
  const claim = allActions.find(a => a.type === 'claim');
  if (claim) { await executeAction(player, cfg, claim); aiStuckTurns[player.id] = 0; return; }

  // Priority 3: Challenge an opponent territory
  const challenge = allActions.find(a => a.type === 'challenge');
  if (challenge) { await executeAction(player, cfg, challenge); aiStuckTurns[player.id] = 0; return; }

  // Priority 4: Fortify an owned territory
  const fortify = allActions.find(a => a.type === 'fortify');
  if (fortify) { await executeAction(player, cfg, fortify); aiStuckTurns[player.id] = 0; return; }

  // Priority 5: Ally at a dog park
  const ally = allActions.find(a => a.type === 'ally');
  if (ally) { await executeAction(player, cfg, ally); aiStuckTurns[player.id] = 0; return; }

  // Priority 6: Take a shortcut
  const shortcut = allActions.find(a => a.type === 'shortcut');
  if (shortcut) { await executeAction(player, cfg, shortcut); aiStuckTurns[player.id] = 0; return; }

  addLogEntry(`${cfg.name} (AI): no affordable actions.`, 'system');
  aiStuckTurns[player.id] = (aiStuckTurns[player.id] || 0) + 1;
}

// ═══════════════════════════════════════════════════════════════════════
//  GAME OVER
// ═══════════════════════════════════════════════════════════════════════

function showGameOver() {
  setPhase('Game Over');
  const winCfg = getConfig(game.winner);
  document.getElementById('go-title').textContent = `${winCfg.name} Wins!`;

  // Build ranking
  const ranked = [...game.players].sort((a, b) =>
    board.getTerritoriesOwnedBy(b.id).length - board.getTerritoriesOwnedBy(a.id).length
  );
  const detail = ranked.map((p, i) => {
    const c = getConfig(p.id);
    const terr = board.getTerritoriesOwnedBy(p.id).length;
    return `${i + 1}. ${c.name} (${ARCHETYPES[c.archetype].name}) \u2014 ${terr} territories`;
  }).join('\n');
  document.getElementById('go-detail').textContent = detail;
  document.getElementById('go-detail').style.whiteSpace = 'pre-line';
  document.getElementById('game-over').classList.add('visible');
}

function exportLog() {
  const lines = [];
  // Header
  lines.push('Uri-Nation Game Log');
  lines.push('='.repeat(40));
  lines.push(`Date: ${new Date().toISOString()}`);
  lines.push(`Rounds: ${game.turnNumber}`);
  lines.push(`Winner: ${getConfig(game.winner)?.name || game.winner}`);
  lines.push('');
  // Players
  lines.push('Players:');
  for (const p of game.players) {
    const c = getConfig(p.id);
    const terr = board.getTerritoriesOwnedBy(p.id).length;
    lines.push(`  ${c.name} (${ARCHETYPES[c.archetype].name}) — ${terr} territories, W:${p.water} Sw:${p.swagger} Dr:${p.drive} Gr:${p.grit} Bd:${p.bond}`);
  }
  lines.push('');
  // Full engine log
  lines.push('Game Log:');
  lines.push('-'.repeat(40));
  for (const entry of game.log) {
    const prefix = entry.player ? `[${getConfig(entry.player)?.name || entry.player}] ` : '';
    lines.push(`R${entry.turn} ${prefix}${entry.message}`);
  }

  const blob = new Blob([lines.join('\n')], { type: 'text/plain' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `game-log-${new Date().toISOString().slice(0,10)}.txt`;
  a.click();
  URL.revokeObjectURL(a.href);
}

// ═══════════════════════════════════════════════════════════════════════
//  MISC HELPERS
// ═══════════════════════════════════════════════════════════════════════

function getConfig(playerId) {
  return playerConfigs.find(c => c.id === playerId);
}

let lastLogIdx = 0;
function flushEngineLog() {
  while (lastLogIdx < game.log.length) {
    const entry = game.log[lastLogIdx];
    const prefix = entry.player ? `[${getConfig(entry.player)?.name || entry.player}] ` : '';
    lastLogIdx++;
  }
}

// ═══════════════════════════════════════════════════════════════════════
//  INIT
// ═══════════════════════════════════════════════════════════════════════

document.addEventListener('DOMContentLoaded', () => {
  initSetup();
  buildPlayerConfigRows(2);
});
</script>
</body>
</html>
