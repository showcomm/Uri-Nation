<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Uri-Nation — Game Runner</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: #1a1a2e;
  color: #e0e0e0;
  height: 100vh;
  overflow: hidden;
}

/* ── Setup Screen ─────────────────────────────────── */
#setup-screen {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100vh;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
}
.setup-panel {
  background: #16213e;
  border: 1px solid #333;
  border-radius: 12px;
  padding: 32px 40px;
  width: 520px;
  max-height: 90vh;
  overflow-y: auto;
}
.setup-panel h1 { font-size: 28px; color: #e8d44d; margin-bottom: 4px; }
.setup-panel h2 { font-size: 14px; color: #888; font-weight: normal; margin-bottom: 24px; }
.setup-section { margin-bottom: 20px; }
.setup-section > label { display: block; font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; }
.setup-section input[type="file"] { font-size: 13px; color: #ccc; }
#board-info { font-size: 12px; color: #6a6; margin-top: 6px; min-height: 18px; }
#board-info.error { color: #c66; }
.player-count-btns { display: flex; gap: 8px; margin-bottom: 12px; }
.player-count-btns button {
  padding: 6px 18px; background: #1a1a2e; border: 1px solid #555; border-radius: 4px;
  color: #ccc; cursor: pointer; font-size: 13px;
}
.player-count-btns button.active { border-color: #4488cc; color: #fff; background: #0f3460; }
.player-row {
  display: grid;
  grid-template-columns: 30px 1fr 1fr 80px;
  gap: 8px;
  align-items: center;
  margin-bottom: 8px;
}
.player-row .player-dot { width: 18px; height: 18px; border-radius: 50%; }
.player-row input, .player-row select {
  padding: 5px 8px; background: #1a1a2e; border: 1px solid #555; border-radius: 4px;
  color: #fff; font-size: 12px;
}
.player-row select { cursor: pointer; }
.big-btn {
  display: block; width: 100%; padding: 12px; margin-top: 16px;
  background: #0f3460; border: 2px solid #4488cc; border-radius: 8px;
  color: #bbd; font-size: 16px; cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
}
.big-btn:hover:not(:disabled) { background: #1a4a80; color: #fff; }
.big-btn:disabled { opacity: 0.4; cursor: default; }

/* ── Game Screen ──────────────────────────────────── */
#game-screen {
  display: none;
  height: 100vh;
  grid-template-columns: 240px 1fr 260px;
  grid-template-rows: 1fr;
}
#game-screen.visible { display: grid; }

/* Sidebar */
#sidebar {
  background: #16213e;
  border-right: 1px solid #333;
  padding: 12px;
  overflow-y: auto;
  min-height: 0;
}
#sidebar h3 {
  font-size: 11px; text-transform: uppercase; letter-spacing: 1px;
  color: #666; margin: 12px 0 6px;
}
#sidebar h3:first-child { margin-top: 0; }
#phase-banner {
  text-align: center; padding: 4px 12px; font-size: 12px; font-weight: bold;
  color: #e8d44d; text-transform: uppercase; letter-spacing: 2px; background: #0f3460;
  border-bottom: 1px solid #333;
}
.stat-row { display: flex; justify-content: space-between; font-size: 13px; padding: 3px 0; }
.stat-row .label { color: #999; }
.stat-row .value { color: #fff; font-weight: bold; min-width: 30px; text-align: right; }
.stat-water .value { color: #40a0e0; }
.stat-swagger .value { color: #e8d44d; }
.stat-drive .value { color: #e07040; }
.stat-grit .value { color: #a0a0b0; }
.stat-bond .value { color: #e05080; }
.player-summary {
  display: flex; align-items: center; gap: 8px;
  padding: 5px 6px; border-radius: 4px; margin-bottom: 4px; font-size: 12px;
}
.player-summary.current { background: rgba(255,255,255,0.08); }
.player-summary .ps-dot { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; }
.player-summary .ps-name { flex: 1; }
.player-summary .ps-terr { color: #7ec850; font-weight: bold; }

/* Board area */
#board-area {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background: #1a1a2e;
}
#board-container {
  flex: 1;
  overflow: auto;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 12px;
  position: relative;
}
#board-svg { cursor: default; }
#board-svg .cell-rect { stroke: rgba(0,0,0,0.15); stroke-width: 0.5; }
#board-svg .cell-interactive { cursor: pointer; }
#board-svg .cell-interactive:hover { stroke: rgba(255,255,255,0.4); stroke-width: 1.5; }
#board-svg .highlight { fill: rgba(0,128,255,0.25); stroke: #0080ff; stroke-width: 2; pointer-events: none; }
#board-svg .highlight-action { fill: rgba(255,200,0,0.2); stroke: #ffc800; stroke-width: 2; pointer-events: none; }
#board-svg .pawn { stroke: #000; stroke-width: 2; }
#board-svg .pawn-label { fill: #000; font-size: 11px; font-weight: bold; pointer-events: none; }
#board-svg .fortify-badge { pointer-events: none; }
#board-svg .fortify-badge-bg { fill: #222; stroke: #fff; stroke-width: 1; }
#board-svg .fortify-badge-text { fill: #fff; font-size: 11px; font-weight: bold; }
#board-svg .owner-fill { pointer-events: none; opacity: 0.45; }
#board-svg .owner-border { fill: none; stroke-width: 4; opacity: 1; pointer-events: none; }

/* Controls bar */
#controls-bar {
  display: flex; align-items: center; gap: 12px;
  padding: 8px 16px; background: #0f3460; border-top: 1px solid #333;
  min-height: 48px; flex-wrap: wrap;
}
#controls-bar .ctrl-btn {
  padding: 5px 14px; background: #16213e; border: 1px solid #4488cc; border-radius: 4px;
  color: #bbd; font-size: 12px; cursor: pointer;
}
#controls-bar .ctrl-btn:hover { background: #1a4a80; color: #fff; }
#controls-bar .ctrl-btn.warn { border-color: #cc4444; color: #c88; }
#controls-bar .ctrl-btn.primary { border-color: #44cc88; color: #8dc; }
#controls-bar .ctrl-info { font-size: 13px; color: #aab; }
#controls-bar .ctrl-spacer { flex: 1; }

/* Dice */
#dice-display {
  display: none;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 100;
  gap: 12px;
  align-items: center;
  pointer-events: none;
}
#dice-display.visible { display: flex; }
.die {
  width: 48px; height: 48px; background: #fff; border-radius: 8px;
  display: flex; align-items: center; justify-content: center;
  font-size: 28px; font-weight: bold; color: #222;
  box-shadow: 3px 3px 8px rgba(0,0,0,0.5);
}
.die-eq { font-size: 20px; color: #fff; }
.die-total { font-size: 32px; font-weight: bold; color: #e8d44d; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }

/* Log panel */
#log-panel {
  background: #16213e;
  border-left: 1px solid #333;
  display: flex;
  flex-direction: column;
  min-height: 0;
}
#log-panel h3 {
  font-size: 11px; text-transform: uppercase; letter-spacing: 1px;
  color: #666; padding: 12px 12px 6px;
}
#game-log {
  flex: 1; overflow-y: auto; padding: 0 12px 12px; font-size: 12px; font-family: monospace;
}
.log-entry { padding: 2px 0; color: #999; border-bottom: 1px solid rgba(255,255,255,0.03); }
.log-entry.round { color: #e8d44d; font-weight: bold; margin-top: 8px; }
.log-entry.action { color: #7ec850; }
.log-entry.challenge { color: #e07040; }
.log-entry.system { color: #4488cc; }
.log-entry.reasoning { color: #b080d0; font-style: italic; }

/* Game over overlay */
#game-over {
  display: none;
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.7);
  z-index: 200;
  align-items: center;
  justify-content: center;
}
#game-over.visible { display: flex; }
#game-over .go-panel {
  background: #16213e; border: 2px solid #e8d44d; border-radius: 12px;
  padding: 32px 48px; text-align: center;
}
#game-over h2 { font-size: 32px; color: #e8d44d; margin-bottom: 8px; }
#game-over p { font-size: 16px; color: #ccc; margin-bottom: 24px; }
</style>
</head>
<body>

<!-- ── Setup Screen ──────────────────────────────── -->
<div id="setup-screen">
  <div class="setup-panel">
    <h1>Uri-Nation</h1>
    <h2>Game Runner</h2>

    <div class="setup-section">
      <label>Load Board JSON</label>
      <input type="file" id="board-file" accept=".json" />
      <div id="board-info"></div>
    </div>

    <div class="setup-section" id="player-setup" style="display:none">
      <label>Players</label>
      <div class="player-count-btns" id="count-btns"></div>
      <div id="player-configs"></div>
    </div>

    <div class="setup-section" id="api-key-section" style="display:none">
      <label>Anthropic API Key (required for Claude AI players)</label>
      <input type="password" id="api-key-input" placeholder="sk-ant-..."
             style="width:100%; padding:5px 8px; background:#1a1a2e; border:1px solid #555; border-radius:4px; color:#fff; font-size:12px;" />
      <div style="font-size:11px; color:#666; margin-top:4px;">Key is stored in sessionStorage only. Never sent anywhere except the Anthropic API.</div>
    </div>

    <button id="btn-start" class="big-btn" disabled>Start Game</button>
  </div>
</div>

<!-- ── Game Screen ───────────────────────────────── -->
<div id="game-screen">
  <div id="sidebar">
    <h3>Turn</h3>
    <div id="turn-info"></div>
    <h3>Current Player</h3>
    <div id="current-player-stats"></div>
    <h3>All Players</h3>
    <div id="all-players-summary"></div>
  </div>

  <div id="board-area">
    <div id="phase-banner">Setup</div>
    <div id="board-container">
      <svg id="board-svg" xmlns="http://www.w3.org/2000/svg"></svg>
      <div id="dice-display">
        <div class="die" id="die1"></div>
        <div class="die" id="die2"></div>
        <span class="die-eq">=</span>
        <span class="die-total" id="die-total"></span>
      </div>
    </div>
    <div id="controls-bar"></div>
  </div>

  <div id="log-panel">
    <h3>Game Log</h3>
    <div id="game-log"></div>
  </div>
</div>

<!-- ── Game Over Overlay ─────────────────────────── -->
<div id="game-over">
  <div class="go-panel">
    <h2 id="go-title"></h2>
    <p id="go-detail"></p>
    <button class="big-btn" onclick="exportLog()" style="border-color:#44cc88;color:#8dc;margin-bottom:8px">Export Log</button>
    <button class="big-btn" onclick="location.reload()">New Game</button>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════════
//  INLINED ENGINE (from tools/engine/ — v1.3.0)
//  Copied here so the file works standalone via file:// protocol.
// ═══════════════════════════════════════════════════════════════════════

// --- archetypes.js ---

const ARCHETYPES = {
  bruiser:  { name: 'Bruiser',  water: 6, swagger: 3, drive: 2, grit: 2, bond: 1 },
  scrapper: { name: 'Scrapper', water: 3, swagger: 2, drive: 3, grit: 1, bond: 2 },
  diplomat: { name: 'Diplomat', water: 4, swagger: 2, drive: 1, grit: 2, bond: 3 },
  yapper:   { name: 'Yapper',  water: 4, swagger: 1, drive: 2, grit: 3, bond: 2 },
};

// --- board.js ---

const SPACE_TYPES = {
  SIDEWALK:     'sidewalk',
  TERRITORY:    'territory',
  HOME:         'home',
  WATER_SOURCE: 'waterSource',
  CHANCE_SPOT:  'chanceSpot',
  DOG_PARK:     'dogPark',
  EVENTS:       'events',
  INTERSECTION: 'intersection',
  PATH:         'path',
  SIDE_STREET:  'sideStreet',
};

function defaultSpaceState() {
  return { owner: null, fortifyTokens: 0 };
}

class Board {
  constructor() {
    this.spaces = new Map();
    this.edges = new Map();
  }
  static fromJSON(json) {
    const b = new Board();
    for (const s of json.spaces) b.addSpace(s);
    for (const e of json.edges) b.addEdge(e.from, e.to, e.driveCost || 0);
    return b;
  }
  addSpace(def) {
    this.spaces.set(def.id, {
      id:           def.id,
      type:         def.type,
      label:        def.label        || def.id,
      facing:       def.facing       || null,
      playerColour: def.playerColour || null,
      pathExit:     def.pathExit     || null,
      ...defaultSpaceState(),
    });
  }
  addEdge(fromId, toId, driveCost = 0) {
    if (!this.edges.has(fromId)) this.edges.set(fromId, []);
    if (!this.edges.has(toId))   this.edges.set(toId, []);
    this.edges.get(fromId).push({ target: toId, driveCost });
    this.edges.get(toId).push({ target: fromId, driveCost });
  }
  getSpace(id)       { return this.spaces.get(id) || null; }
  getNeighbors(id)   { return (this.edges.get(id) || []).map(e => ({ space: this.spaces.get(e.target), driveCost: e.driveCost })); }
  getEdges(id)       { return this.edges.get(id) || []; }
  getSpacesByType(t) { const o = []; for (const s of this.spaces.values()) if (s.type === t) o.push(s); return o; }
  getTerritoriesOwnedBy(pid) { const o = []; for (const s of this.spaces.values()) if (s.type === SPACE_TYPES.TERRITORY && s.owner === pid) o.push(s); return o; }
  getAllSpaces()      { return [...this.spaces.values()]; }
  getHomeSpace(playerId, players) {
    const player = players.find(p => p.id === playerId);
    if (!player) return null;
    for (const s of this.spaces.values()) {
      if (s.type === SPACE_TYPES.HOME && s.playerColour === player.colour) return s;
    }
    return null;
  }
  getHomeNeighbourhood(playerId, players) {
    const home = this.getHomeSpace(playerId, players);
    if (!home) return [];
    return this.getNeighbors(home.id)
      .filter(n => n.space.type === SPACE_TYPES.TERRITORY)
      .map(n => n.space);
  }
  isHomeNeighbourhood(territoryId, playerId, players) {
    return this.getHomeNeighbourhood(playerId, players).some(s => s.id === territoryId);
  }
  areAllied(playerIdA, playerIdB, players) {
    const a = players.find(p => p.id === playerIdA);
    return a ? a.allies.includes(playerIdB) : false;
  }
  getMovementCost(fromId, toId) {
    const edges = this.edges.get(fromId);
    if (!edges) return null;
    const e = edges.find(e => e.target === toId);
    return e ? e.driveCost : null;
  }
  getConnectedTerritoryGroups(pid) {
    const owned = new Set();
    for (const s of this.spaces.values()) if (s.type === SPACE_TYPES.TERRITORY && s.owner === pid) owned.add(s.id);
    const visited = new Set(); const groups = [];
    for (const id of owned) {
      if (visited.has(id)) continue;
      const group = []; const stack = [id];
      while (stack.length > 0) {
        const cur = stack.pop();
        if (visited.has(cur)) continue;
        visited.add(cur); group.push(cur);
        for (const e of (this.edges.get(cur) || [])) if (owned.has(e.target) && !visited.has(e.target)) stack.push(e.target);
      }
      groups.push(group);
    }
    return groups;
  }
  isInCluster(tid, pid) {
    for (const g of this.getConnectedTerritoryGroups(pid)) if (g.includes(tid) && g.length >= 3) return true;
    return false;
  }
  resetState() { for (const s of this.spaces.values()) Object.assign(s, defaultSpaceState()); }
  toJSON() {
    const spaces = []; for (const s of this.spaces.values()) spaces.push({ ...s });
    const edges = []; const seen = new Set();
    for (const [fid, conns] of this.edges) for (const c of conns) {
      const key = [fid, c.target].sort().join('|');
      if (seen.has(key)) continue; seen.add(key);
      edges.push({ from: fid, to: c.target, driveCost: c.driveCost });
    }
    return { spaces, edges };
  }
}

// --- game.js ---

const DEFAULTS = {
  swaggerPerTerritories: 3,
  maxFortify:            1,
  maxTurns:              30,
  territoryWinThreshold: 15,
};

function createPlayer(id, archetypeKey, homeSpaceId, colour) {
  const arch = ARCHETYPES[archetypeKey];
  if (!arch) throw new Error(`Unknown archetype: ${archetypeKey}`);
  return {
    id, colour, archetype: archetypeKey, position: homeSpaceId,
    water: arch.water, swagger: arch.swagger, drive: arch.drive, grit: arch.grit, bond: arch.bond,
    allies: [],
  };
}

class Game {
  constructor(board, players, config = {}) {
    this.board = board; this.players = players;
    this.config = { ...DEFAULTS, ...config };
    this.turnNumber = 0; this.currentPlayerIndex = 0;
    this.gameOver = false; this.winner = null; this.log = [];
    this.pendingAlliances = new Map();
  }
  getPlayer(id)        { return this.players.find(p => p.id === id); }
  getCurrentPlayer()   { return this.players[this.currentPlayerIndex]; }
  getArchetype(player) { return ARCHETYPES[player.archetype]; }
  calculateSwaggerIncome(pid) {
    let total = 0;
    for (const g of this.board.getConnectedTerritoryGroups(pid)) total += Math.floor(g.length / this.config.swaggerPerTerritories);
    return total;
  }
  applyTerritoryIncome(pid) {
    const p = this.getPlayer(pid);
    const sw = this.calculateSwaggerIncome(pid);
    if (sw > 0) { p.swagger += sw; this._log(pid, `territory income: +${sw} swagger`); }
  }

  // ── Validation ──
  canClaim(pid, tid) {
    const p = this.getPlayer(pid), s = this.board.getSpace(tid);
    if (!s || s.type !== SPACE_TYPES.TERRITORY) return { ok: false, reason: 'Not a territory' };
    if (s.owner !== null) return { ok: false, reason: 'Occupied' };
    if (p.water < 2) return { ok: false, reason: 'Need 2 water' };
    if (p.swagger < 1) return { ok: false, reason: 'Need 1 swagger' };
    return { ok: true, waterCost: 2, swaggerCost: 1 };
  }
  canChallenge(pid, tid) {
    const p = this.getPlayer(pid), s = this.board.getSpace(tid);
    if (!s) return { ok: false, reason: 'Space not found' };
    if (s.type === SPACE_TYPES.HOME) return { ok: false, reason: 'Cannot challenge a home turf' };
    if (s.type !== SPACE_TYPES.TERRITORY) return { ok: false, reason: 'Not a territory' };
    if (s.owner === null) return { ok: false, reason: 'Empty — use Claim' };
    if (s.owner === pid) return { ok: false, reason: 'Own territory' };
    if (p.water < 2) return { ok: false, reason: 'Need 2 water' };
    if (p.drive < 1) return { ok: false, reason: 'Need 1 drive' };
    if (this.board.areAllied(pid, s.owner, this.players)) return { ok: false, reason: 'Alliance protection' };
    // Home neighbourhood transitive check
    if (this.board.isHomeNeighbourhood(tid, s.owner, this.players)) {
      const defender = this.getPlayer(s.owner);
      for (const allyId of defender.allies) {
        if (this.board.areAllied(pid, allyId, this.players))
          return { ok: false, reason: 'Alliance protection — home neighbourhood' };
      }
    }
    return { ok: true, waterCost: 2, driveCost: 1 };
  }
  canFortify(pid, tid) {
    const p = this.getPlayer(pid), s = this.board.getSpace(tid);
    if (!s || s.type !== SPACE_TYPES.TERRITORY) return { ok: false, reason: 'Not a territory' };
    if (s.owner !== pid) return { ok: false, reason: 'Not yours' };
    if (s.fortifyTokens >= this.config.maxFortify) return { ok: false, reason: 'Max fortify' };
    if (p.water < 1) return { ok: false, reason: 'Need 1 water' };
    if (p.grit < 1) return { ok: false, reason: 'Need 1 grit' };
    return { ok: true, waterCost: 1, gritCost: 1 };
  }
  canAlly(pid, dogParkSpaceId) {
    const p = this.getPlayer(pid), s = this.board.getSpace(dogParkSpaceId);
    if (!s || s.type !== SPACE_TYPES.DOG_PARK) return { ok: false, reason: 'Not a dog park' };
    if (p.water < 1) return { ok: false, reason: 'Need 1 water' };
    if (p.bond < 1) return { ok: false, reason: 'Need 1 bond' };
    return { ok: true, waterCost: 1, bondCost: 1 };
  }
  canBreakAlliance(pid, alliedPlayerId) {
    const p = this.getPlayer(pid);
    if (!p.allies.includes(alliedPlayerId)) return { ok: false, reason: 'Not allied' };
    if (p.water < 1) return { ok: false, reason: 'Need 1 water' };
    if (p.swagger < 1) return { ok: false, reason: 'Need 1 swagger' };
    return { ok: true, waterCost: 1, swaggerCost: 1 };
  }
  canDrink(pid) {
    const p = this.getPlayer(pid);
    if (p.drive < 1) return { ok: false, reason: 'Need 1 drive' };
    return { ok: true, driveCost: 1 };
  }
  canReClaim(pid) {
    const p = this.getPlayer(pid);
    if (p.swagger >= 1) return { ok: true, resource: 'swagger' };
    if (p.grit >= 1)    return { ok: true, resource: 'grit' };
    return { ok: false, reason: 'Need 1 swagger or 1 grit' };
  }

  // ── Actions ──
  claim(pid, tid) {
    const c = this.canClaim(pid, tid); if (!c.ok) return { success: false, reason: c.reason };
    const p = this.getPlayer(pid), s = this.board.getSpace(tid);
    p.water -= c.waterCost; p.swagger -= c.swaggerCost; s.owner = pid;
    this._log(pid, `claimed ${tid}`); return { success: true };
  }
  payChallengeCost(pid, tid) {
    const c = this.canChallenge(pid, tid); if (!c.ok) return { success: false, reason: c.reason };
    const p = this.getPlayer(pid);
    p.water -= c.waterCost; p.drive -= c.driveCost;
    this._log(pid, `paid challenge cost for ${tid}`);
    return { success: true, defenderId: this.board.getSpace(tid).owner };
  }
  resolveChallenge(attackerId, defenderId, tid, attackRoll, defendRoll) {
    const att = this.getPlayer(attackerId), def = this.getPlayer(defenderId), space = this.board.getSpace(tid);
    let aT = attackRoll, dT = defendRoll;
    dT += space.fortifyTokens;
    const cluster = this.board.isInCluster(tid, defenderId);
    let outcome;
    if (aT > dT) outcome = 'attackerWins';
    else if (aT === dT) outcome = cluster ? 'defenderWins' : 'tie';
    else outcome = 'defenderWins';
    const result = { outcome, attackRoll, defendRoll, attackTotal: aT, defendTotal: dT, fortifyBonus: space.fortifyTokens, clusterRule: cluster };
    if (outcome === 'attackerWins') {
      space.owner = null; space.fortifyTokens = 0;
      result.canReClaim = this.canReClaim(attackerId);
      this._log(attackerId, `won challenge at ${tid} (${aT} vs ${dT})`);
    } else if (outcome === 'defenderWins') {
      this._log(attackerId, `lost challenge at ${tid}`);
    }
    return result;
  }
  reClaim(pid, tid, useResource) {
    const p = this.getPlayer(pid), s = this.board.getSpace(tid);
    if (useResource === 'swagger') { if (p.swagger < 1) return { success: false }; p.swagger -= 1; }
    else if (useResource === 'grit') { if (p.grit < 1) return { success: false }; p.grit -= 1; }
    else return { success: false };
    s.owner = pid;
    this._log(pid, `re-claimed ${tid} with ${useResource}`); return { success: true };
  }
  declineReClaim(tid) { this._log(null, `re-claim declined at ${tid}`); return { success: true }; }
  fortify(pid, tid) {
    const c = this.canFortify(pid, tid); if (!c.ok) return { success: false, reason: c.reason };
    const p = this.getPlayer(pid), s = this.board.getSpace(tid);
    p.water -= c.waterCost; p.grit -= c.gritCost; s.fortifyTokens += 1;
    this._log(pid, `fortified ${tid} (${s.fortifyTokens}/${this.config.maxFortify})`); return { success: true };
  }

  // ── Alliance ──
  ally(pid, dogParkSpaceId) {
    const c = this.canAlly(pid, dogParkSpaceId); if (!c.ok) return { success: false, reason: c.reason };
    const p = this.getPlayer(pid);
    p.water -= c.waterCost; p.bond -= c.bondCost;
    this.pendingAlliances.set(dogParkSpaceId, pid);
    this._log(pid, `initiated alliance at ${dogParkSpaceId}`); return { success: true };
  }
  compulsoryBondJoin(pid, dogParkSpaceId) {
    const p = this.getPlayer(pid);
    if (!this.pendingAlliances.has(dogParkSpaceId)) return { success: false, reason: 'No pending alliance' };
    const initiatorId = this.pendingAlliances.get(dogParkSpaceId);
    if (initiatorId === pid) return { success: false, reason: 'Cannot join own alliance' };
    if (p.allies.includes(initiatorId)) return { success: false, reason: 'Already allied' };
    if (p.water < 1) return { success: false, reason: 'No water' };
    const initiator = this.getPlayer(initiatorId);
    p.water -= 1;
    if (!p.allies.includes(initiatorId)) p.allies.push(initiatorId);
    if (!initiator.allies.includes(pid)) initiator.allies.push(pid);
    this.pendingAlliances.delete(dogParkSpaceId);
    this._log(pid, `joined alliance with ${initiatorId} at ${dogParkSpaceId}`);
    // Friendship sacrifice: clear claims in each other's home neighbourhood
    const cleared = [];
    const joinerHood = this.board.getHomeNeighbourhood(pid, this.players);
    for (const t of joinerHood) {
      if (t.owner === initiatorId) {
        t.owner = null; t.fortifyTokens = 0; cleared.push(t.id);
        this._log(initiatorId, `claim cleared at ${t.id} (friendship sacrifice)`);
      }
    }
    const initiatorHood = this.board.getHomeNeighbourhood(initiatorId, this.players);
    for (const t of initiatorHood) {
      if (t.owner === pid) {
        t.owner = null; t.fortifyTokens = 0; cleared.push(t.id);
        this._log(pid, `claim cleared at ${t.id} (friendship sacrifice)`);
      }
    }
    return { success: true, cleared };
  }
  breakAlliance(pid, alliedPlayerId) {
    const c = this.canBreakAlliance(pid, alliedPlayerId); if (!c.ok) return { success: false, reason: c.reason };
    const p = this.getPlayer(pid), ally = this.getPlayer(alliedPlayerId);
    p.water -= c.waterCost; p.swagger -= c.swaggerCost;
    p.allies = p.allies.filter(id => id !== alliedPlayerId);
    ally.allies = ally.allies.filter(id => id !== pid);
    this._log(pid, `broke alliance with ${alliedPlayerId}`); return { success: true };
  }

  // ── Shortcut ──
  takeShortcut(pid, pathEntryId) {
    const p = this.getPlayer(pid), s = this.board.getSpace(pathEntryId);
    if (!s || s.type !== SPACE_TYPES.PATH) return { success: false, reason: 'Not a path space' };
    if (p.position !== pathEntryId) return { success: false, reason: 'Not at path entry' };
    if (!s.pathExit) return { success: false, reason: 'No exit' };
    if (p.drive < 1) return { success: false, reason: 'Need 1 drive' };
    p.drive -= 1; p.position = s.pathExit;
    this._log(pid, `took shortcut ${pathEntryId} → ${s.pathExit}`);
    return { success: true, exitSpaceId: s.pathExit };
  }

  // ── Drink ──
  drink(pid, waterGain) {
    const c = this.canDrink(pid); if (!c.ok) return { success: false, reason: c.reason };
    const p = this.getPlayer(pid), arch = this.getArchetype(p);
    p.drive -= c.driveCost; p.water = Math.min(p.water + waterGain, arch.water);
    this._log(pid, `drank: +${waterGain} water (now ${p.water}/${arch.water})`); return { success: true };
  }

  // ── Movement ──
  getPassThroughEffects(spaceId, pid) {
    const s = this.board.getSpace(spaceId); if (!s) return [];
    const effects = [];
    switch (s.type) {
      case SPACE_TYPES.CHANCE_SPOT: effects.push({ type: 'chanceCard' }); break;
      case SPACE_TYPES.DOG_PARK:
        if (this.pendingAlliances.has(spaceId)) {
          const initId = this.pendingAlliances.get(spaceId);
          const player = this.getPlayer(pid);
          if (initId !== pid && player && !player.allies.includes(initId)) {
            effects.push({ type: 'compulsoryBond', dogParkSpaceId: spaceId }); break;
          }
        }
        effects.push({ type: 'dogPark' }); break;
      case SPACE_TYPES.EVENTS: effects.push({ type: 'eventsCard' }); break;
      case SPACE_TYPES.HOME: {
        const player = this.getPlayer(pid);
        if (player && s.playerColour === player.colour) effects.push({ type: 'homeResupply' });
        break;
      }
      case SPACE_TYPES.PATH:
        if (s.pathExit) effects.push({ type: 'pathEntry', exitSpaceId: s.pathExit });
        break;
    }
    return effects;
  }
  movePlayer(pid, path) {
    const p = this.getPlayer(pid);
    if (path.length === 0) return { success: true, driveCost: 0, effects: [] };
    if (path[0] !== p.position) return { success: false, reason: 'Path must start at current position' };
    let totalDrive = 0;
    for (let i = 1; i < path.length; i++) {
      const cost = this.board.getMovementCost(path[i-1], path[i]);
      if (cost === null) return { success: false, reason: `No connection: ${path[i-1]} -> ${path[i]}` };
      totalDrive += cost;
    }
    if (p.drive < totalDrive) return { success: false, reason: `Not enough drive (need ${totalDrive})` };
    const effects = [];
    for (let i = 1; i < path.length; i++) {
      for (const eff of this.getPassThroughEffects(path[i], pid)) effects.push({ ...eff, spaceId: path[i] });
    }
    p.drive -= totalDrive; p.position = path[path.length - 1];
    this._log(pid, `moved to ${p.position} (${totalDrive} drive)`);
    return { success: true, driveCost: totalDrive, effects };
  }
  applyDogPark(pid) { this.getPlayer(pid).bond += 1; this._log(pid, '+1 bond (dog park)'); }
  applyHomeResupply(pid) {
    const p = this.getPlayer(pid), arch = this.getArchetype(p);
    p.water = arch.water;
    p.swagger = Math.max(p.swagger, arch.swagger);
    p.drive   = Math.max(p.drive, arch.drive);
    p.grit    = Math.max(p.grit, arch.grit);
    p.bond    = Math.max(p.bond, arch.bond);
    this._log(pid, 'home resupply');
  }

  // ── Win conditions ──
  checkWinConditions() {
    for (const p of this.players) {
      const c = this.board.getTerritoriesOwnedBy(p.id).length;
      if (c >= this.config.territoryWinThreshold) {
        this.gameOver = true; this.winner = p.id;
        this._log(p.id, `wins — ${c} territories!`);
        return { gameOver: true, winner: p.id, reason: 'territory threshold' };
      }
    }
    // Last-dog-standing: only check at end of a full round (after all players have gone)
    // and only after round 5 to give everyone time to recover from early losses
    if (this.turnNumber >= 5 && this.currentPlayerIndex >= this.players.length - 1) {
      const wt = this.players.filter(p => this.board.getTerritoriesOwnedBy(p.id).length > 0);
      if (wt.length === 1) {
        this.gameOver = true; this.winner = wt[0].id;
        return { gameOver: true, winner: wt[0].id, reason: 'last standing' };
      }
    }
    if (this.turnNumber >= this.config.maxTurns) {
      const ranked = [...this.players].sort((a, b) => {
        const aT = this.board.getTerritoriesOwnedBy(a.id), bT = this.board.getTerritoriesOwnedBy(b.id);
        if (bT.length !== aT.length) return bT.length - aT.length;
        const aF = aT.reduce((s,t) => s+t.fortifyTokens,0), bF = bT.reduce((s,t) => s+t.fortifyTokens,0);
        if (bF !== aF) return bF - aF;
        return b.swagger - a.swagger;
      });
      this.gameOver = true; this.winner = ranked[0].id;
      return { gameOver: true, winner: ranked[0].id, reason: 'turn limit', rankings: ranked.map(p => p.id) };
    }
    return { gameOver: false };
  }

  // ── Turn management ──
  startRound() {
    this.turnNumber += 1; this.currentPlayerIndex = 0;
    this._log(null, `=== Round ${this.turnNumber} ===`);
  }
  advancePlayer() { this.currentPlayerIndex += 1; return this.currentPlayerIndex < this.players.length; }

  static rollD6(rng) { if (rng) return rng(1, 6); return Math.floor(Math.random() * 6) + 1; }
  static roll2D6(rng) { return Game.rollD6(rng) + Game.rollD6(rng); }
  rollMovement(pid, rng) {
    return Game.roll2D6(rng);
  }
  getState() {
    return {
      turnNumber: this.turnNumber, currentPlayerIndex: this.currentPlayerIndex,
      gameOver: this.gameOver, winner: this.winner,
      players: this.players.map(p => ({ ...p, allies: [...p.allies] })),
      board: this.board.toJSON(),
      pendingAlliances: Object.fromEntries(this.pendingAlliances),
      log: [...this.log],
    };
  }
  _log(pid, msg) { this.log.push({ turn: this.turnNumber, player: pid, message: msg }); }
}

// ═══════════════════════════════════════════════════════════════════════
//  CONSTANTS & GLOBALS
// ═══════════════════════════════════════════════════════════════════════

const COLOUR_HEX = { blue: '#5080e0', purple: '#9060c0', orange: '#e0a050', yellow: '#e0d050' };
const COLOUR_ORDER = ['blue', 'purple', 'orange', 'yellow'];
const SVG_NS = 'http://www.w3.org/2000/svg';
const CELL = 64;

// ── Stamp footprints (inlined from board-builder) ──

const COMPOUND_FP = [
  // rot 0  N — yard on top
  [{dr:0,dc:0,sub:'yard'},{dr:0,dc:1,sub:'yard'},
   {dr:1,dc:0,sub:'house'},{dr:1,dc:1,sub:'house'},
   {dr:2,dc:0,sub:'house'},{dr:2,dc:1,sub:'house'}],
  // rot 1  E — yard on right
  [{dr:0,dc:0,sub:'house'},{dr:0,dc:1,sub:'house'},{dr:0,dc:2,sub:'yard'},
   {dr:1,dc:0,sub:'house'},{dr:1,dc:1,sub:'house'},{dr:1,dc:2,sub:'yard'}],
  // rot 2  S — yard on bottom
  [{dr:0,dc:0,sub:'house'},{dr:0,dc:1,sub:'house'},
   {dr:1,dc:0,sub:'house'},{dr:1,dc:1,sub:'house'},
   {dr:2,dc:0,sub:'yard'},{dr:2,dc:1,sub:'yard'}],
  // rot 3  W — yard on left
  [{dr:0,dc:0,sub:'yard'},{dr:0,dc:1,sub:'house'},{dr:0,dc:2,sub:'house'},
   {dr:1,dc:0,sub:'yard'},{dr:1,dc:1,sub:'house'},{dr:1,dc:2,sub:'house'}],
];

const STAMP_FP = {
  sidewalk: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:1,dc:0,sub:'main'}],
    ],
    colors: {main:'#d4b896'},
  },
  road: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:1,dc:0,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'}],
    ],
    colors: {main:'#888888'},
  },
  intersection: {
    fp: [[{dr:0,dc:0,sub:'main'}]],
    colors: {main:'#aaaaaa'},
  },
  territory: {
    fp: COMPOUND_FP,
    colors: {yard:'#7ec850', house:'#c87850'},
  },
  home: {
    fp: COMPOUND_FP,
    colors: {yard:'#88aaff', house:'#4477dd'},
  },
  dogPark: {
    fp: [[{dr:0,dc:0,sub:'main'}]],
    colors: {main:'#40c080'},
  },
  waterPark: {
    fp: [[{dr:0,dc:0,sub:'main'}]],
    colors: {main:'#40a8a0'},
  },
  pathStraight: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:1,dc:0,sub:'main'}],
    ],
    colors: {main:'#c8a878'},
  },
  pathCorner: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:1,dc:1,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:1,dc:1,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:1,dc:1,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:1,dc:1,sub:'main'}],
    ],
    colors: {main:'#c8a878'},
  },
  sidewalk3: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:0,dc:2,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:2,dc:0,sub:'main'}],
    ],
    colors: {main:'#d4b896'},
  },
  road3: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:2,dc:0,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:0,dc:2,sub:'main'}],
    ],
    colors: {main:'#888888'},
  },
  pathStraight3: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:0,dc:2,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:2,dc:0,sub:'main'}],
    ],
    colors: {main:'#c8a878'},
  },
};

const HOME_PLAYER_COLORS = {
  blue:   {yard:'#88aaff', house:'#4477dd'},
  purple: {yard:'#cc88ff', house:'#8844cc'},
  orange: {yard:'#ffbb66', house:'#dd8833'},
  yellow: {yard:'#ffee66', house:'#ccbb33'},
};

function getStampCells(type, rot) {
  const s = STAMP_FP[type];
  if (!s) return [];
  return s.fp[rot % s.fp.length];
}

function getCellColor(type, sub, playerColour) {
  if (type === 'home' && playerColour && HOME_PLAYER_COLORS[playerColour])
    return HOME_PLAYER_COLORS[playerColour][sub] || '#888';
  return STAMP_FP[type]?.colors[sub] || '#555';
}

let boardData = null;       // raw JSON
let board = null;           // Board instance
let game = null;            // Game instance
let playerConfigs = [];     // { id, name, archetype, isAI, homeSpaceId, colour }
let positions = {};         // spaceId → { x, y } in SVG coords (first cell center)
let cellToSpaceId = {};     // "row,col" → spaceId
let spaceIdToCells = {};    // spaceId → [{row,col}, ...]
let gridRows = 0, gridCols = 0;
let svgEl = null;
let layerCells, layerOverlay, layerHighlight, layerPawns;

// Interaction promises
let _resolveSpaceClick = null;
let _validSpaceIds = null;
let _resolveControlBtn = null;

// ═══════════════════════════════════════════════════════════════════════
//  SETUP SCREEN
// ═══════════════════════════════════════════════════════════════════════

function initSetup() {
  document.getElementById('board-file').addEventListener('change', onBoardFileChange);

  // Player count buttons
  const countBtns = document.getElementById('count-btns');
  for (let n = 2; n <= 4; n++) {
    const btn = document.createElement('button');
    btn.textContent = n;
    btn.dataset.count = n;
    if (n === 2) btn.classList.add('active');
    btn.addEventListener('click', () => {
      countBtns.querySelectorAll('button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      buildPlayerConfigRows(n);
    });
    countBtns.appendChild(btn);
  }

  document.getElementById('btn-start').addEventListener('click', onStartGame);
}

function onBoardFileChange(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      boardData = JSON.parse(ev.target.result);
      const homeCount = boardData.spaces.filter(s => s.type === SPACE_TYPES.HOME).length;
      const info = document.getElementById('board-info');
      info.textContent = `${boardData.spaces.length} spaces, ${boardData.edges.length} edges, ${homeCount} homes`;
      info.className = '';
      document.getElementById('player-setup').style.display = '';

      // Limit player count to available homes
      const maxPlayers = Math.min(4, homeCount);
      const countBtns = document.getElementById('count-btns');
      countBtns.querySelectorAll('button').forEach(b => {
        const n = parseInt(b.dataset.count);
        b.disabled = n > maxPlayers;
        b.classList.remove('active');
      });
      // Select first valid count
      const firstValid = countBtns.querySelector(`button:not(:disabled)`);
      if (firstValid) { firstValid.classList.add('active'); buildPlayerConfigRows(parseInt(firstValid.dataset.count)); }

      document.getElementById('btn-start').disabled = homeCount < 2;
    } catch (err) {
      const info = document.getElementById('board-info');
      info.textContent = 'Error: ' + err.message;
      info.className = 'error';
    }
  };
  reader.readAsText(file);
}

function buildPlayerConfigRows(count) {
  const container = document.getElementById('player-configs');
  container.innerHTML = '';
  const archetypeKeys = Object.keys(ARCHETYPES);
  for (let i = 0; i < count; i++) {
    const colour = COLOUR_HEX[COLOUR_ORDER[i]] || '#888';
    const row = document.createElement('div');
    row.className = 'player-row';
    row.innerHTML = `
      <span class="player-dot" style="background:${colour}"></span>
      <input type="text" value="Player ${i+1}" data-field="name" />
      <select data-field="archetype">
        ${archetypeKeys.map((k, j) => `<option value="${k}" ${j === i % archetypeKeys.length ? 'selected' : ''}>${ARCHETYPES[k].name}</option>`).join('')}
      </select>
      <select data-field="control">
        <option value="human" ${i === 0 ? 'selected' : ''}>Human</option>
        <option value="ai">AI (Algorithmic)</option>
        <option value="claude" ${i > 0 ? 'selected' : ''}>Claude AI</option>
      </select>
    `;
    container.appendChild(row);
  }

  // Wire up control change listeners to show/hide API key section
  container.querySelectorAll('[data-field="control"]').forEach(sel => {
    sel.addEventListener('change', updateApiKeyVisibility);
  });
  updateApiKeyVisibility();

  // Load saved API key
  const savedKey = sessionStorage.getItem('anthropic_api_key');
  if (savedKey) document.getElementById('api-key-input').value = savedKey;
}

function updateApiKeyVisibility() {
  const controls = document.querySelectorAll('#player-configs [data-field="control"]');
  const hasClaude = [...controls].some(sel => sel.value === 'claude');
  document.getElementById('api-key-section').style.display = hasClaude ? 'block' : 'none';
}

function onStartGame() {
  if (!boardData) return;
  const rows = document.querySelectorAll('#player-configs .player-row');
  const homes = boardData.spaces.filter(s => s.type === SPACE_TYPES.HOME);

  playerConfigs = [];
  board = Board.fromJSON(boardData);

  for (let i = 0; i < rows.length; i++) {
    const name = rows[i].querySelector('[data-field="name"]').value.trim() || `Player ${i+1}`;
    const archetype = rows[i].querySelector('[data-field="archetype"]').value;
    const controlVal = rows[i].querySelector('[data-field="control"]').value;
    const isAI = controlVal === 'ai' || controlVal === 'claude';
    const isClaude = controlVal === 'claude';
    const homeId = homes[i].id;
    const id = `p${i+1}`;
    // Read colour from the home space's playerColour field
    const homeSpace = board.getSpace(homeId);
    const colour = (homeSpace && homeSpace.playerColour) || COLOUR_ORDER[i];
    playerConfigs.push({ id, name, archetype, isAI, isClaude, homeSpaceId: homeId, colour });
  }

  // Build position map from _positions
  buildPositionMap();

  // Create players (v1.3.0: pass colour)
  const players = playerConfigs.map(c => createPlayer(c.id, c.archetype, c.homeSpaceId, c.colour));
  game = new Game(board, players);

  // Starting claim: each player gets one free adjacent territory
  for (const p of players) {
    const homeNeighbors = board.getHomeNeighbourhood(p.id, players);
    const unclaimed = homeNeighbors.find(t => t.owner === null);
    if (unclaimed) {
      unclaimed.owner = p.id;
      game._log(p.id, `starting claim: ${unclaimed.id}`);
    }
  }

  // Save API key to sessionStorage
  const apiKeyVal = document.getElementById('api-key-input').value.trim();
  if (apiKeyVal) sessionStorage.setItem('anthropic_api_key', apiKeyVal);

  // Switch to game screen
  document.getElementById('setup-screen').style.display = 'none';
  document.getElementById('game-screen').classList.add('visible');

  // Build SVG
  buildBoardSVG();
  updateOverlay();
  updatePawns();
  updateSidebar();

  // Start the game loop
  runGame();
}

// ═══════════════════════════════════════════════════════════════════════
//  POSITION MAP
// ═══════════════════════════════════════════════════════════════════════

function buildPositionMap() {
  positions = {};
  cellToSpaceId = {};
  spaceIdToCells = {};
  gridRows = 0;
  gridCols = 0;

  if (boardData._grid) {
    gridRows = boardData._grid.rows || 0;
    gridCols = boardData._grid.cols || 0;
  }

  if (boardData._positions && boardData._positions.length > 0) {
    for (const p of boardData._positions) {
      const key = `${p.row},${p.col}`;
      cellToSpaceId[key] = p.id;
      if (!spaceIdToCells[p.id]) spaceIdToCells[p.id] = [];
      spaceIdToCells[p.id].push({ row: p.row, col: p.col });
      // First occurrence becomes the pawn position
      if (!positions[p.id]) {
        positions[p.id] = { x: p.col * CELL + CELL / 2, y: p.row * CELL + CELL / 2 };
      }
    }
  } else {
    // Fallback: arrange in a grid
    const count = boardData.spaces.length;
    const cols = Math.ceil(Math.sqrt(count * 1.5));
    gridCols = cols;
    gridRows = Math.ceil(count / cols);
    boardData.spaces.forEach((s, i) => {
      const col = i % cols;
      const row = Math.floor(i / cols);
      positions[s.id] = { x: col * CELL + CELL / 2, y: row * CELL + CELL / 2 };
      const key = `${row},${col}`;
      cellToSpaceId[key] = s.id;
      spaceIdToCells[s.id] = [{ row, col }];
    });
  }
}

// ═══════════════════════════════════════════════════════════════════════
//  SVG RENDERER
// ═══════════════════════════════════════════════════════════════════════

function buildBoardSVG() {
  svgEl = document.getElementById('board-svg');
  svgEl.innerHTML = '';

  // ViewBox from grid dimensions
  const vw = gridCols * CELL;
  const vh = gridRows * CELL;
  svgEl.setAttribute('viewBox', `0 0 ${vw} ${vh}`);
  svgEl.setAttribute('width', vw);
  svgEl.setAttribute('height', vh);

  // Background
  const bg = svgCreate('rect', { x: 0, y: 0, width: vw, height: vh, fill: '#2a2a3e' });
  svgEl.appendChild(bg);

  // Layers
  layerCells     = svgG('cells-layer');
  layerOverlay   = svgG('overlay-layer');
  layerHighlight = svgG('highlight-layer');
  layerPawns     = svgG('pawns-layer');
  svgEl.append(layerCells, layerOverlay, layerHighlight, layerPawns);

  // Paint grid components
  if (boardData._grid && boardData._grid.components) {
    for (const comp of boardData._grid.components) {
      const cells = getStampCells(comp.type, comp.rotation);
      for (const cell of cells) {
        const absRow = comp.row + cell.dr;
        const absCol = comp.col + cell.dc;
        const x = absCol * CELL;
        const y = absRow * CELL;
        const fill = getCellColor(comp.type, cell.sub, comp.playerColour);
        const key = `${absRow},${absCol}`;
        const spaceId = cellToSpaceId[key] || null;

        const rect = svgCreate('rect', {
          x, y, width: CELL, height: CELL,
          fill,
          class: 'cell-rect' + (spaceId ? ' cell-interactive' : ''),
        });
        if (spaceId) rect.dataset.spaceId = spaceId;
        layerCells.appendChild(rect);
      }
    }
  }

  // Click handler (event delegation)
  svgEl.addEventListener('click', (e) => {
    const el = e.target.closest('[data-space-id]');
    if (!el) return;
    const sid = el.dataset.spaceId;
    if (_resolveSpaceClick && _validSpaceIds && _validSpaceIds.includes(sid)) {
      _resolveSpaceClick(sid);
      _resolveSpaceClick = null;
      _validSpaceIds = null;
    }
  });
}

function updateOverlay() {
  layerOverlay.innerHTML = '';
  for (const s of board.getAllSpaces()) {
    const cells = spaceIdToCells[s.id];
    if (!cells || cells.length === 0) continue;

    // Owned territory — fill cells with player color
    if (s.owner) {
      const cfg = playerConfigs.find(c => c.id === s.owner);
      if (cfg) {
        const colour = COLOUR_HEX[cfg.colour] || cfg.colour;
        // Color fill on each cell
        for (const cell of cells) {
          const fill = svgCreate('rect', {
            x: cell.col * CELL, y: cell.row * CELL,
            width: CELL, height: CELL,
            fill: colour, class: 'owner-fill',
          });
          layerOverlay.appendChild(fill);
        }
        // Prominent border around each cell
        for (const cell of cells) {
          const border = svgCreate('rect', {
            x: cell.col * CELL + 2, y: cell.row * CELL + 2,
            width: CELL - 4, height: CELL - 4,
            stroke: colour, class: 'owner-border',
          });
          layerOverlay.appendChild(border);
        }
      }
    }

    // Fortify count as a number badge (top-right corner of first cell)
    if (s.fortifyTokens > 0) {
      const fc = cells[0];
      const bx = fc.col * CELL + CELL - 10;
      const by = fc.row * CELL + 12;
      const bg = svgCreate('circle', { cx: bx, cy: by, r: 8, class: 'fortify-badge fortify-badge-bg' });
      layerOverlay.appendChild(bg);
      const txt = svgCreate('text', {
        x: bx, y: by,
        'text-anchor': 'middle', 'dominant-baseline': 'central',
        class: 'fortify-badge fortify-badge-text',
      });
      txt.textContent = s.fortifyTokens;
      layerOverlay.appendChild(txt);
    }

    // Pending alliance marker at dog parks
    if (game && s.type === SPACE_TYPES.DOG_PARK && game.pendingAlliances.has(s.id)) {
      const initId = game.pendingAlliances.get(s.id);
      const initCfg = playerConfigs.find(c => c.id === initId);
      const fc = cells[0];
      const heart = svgCreate('text', {
        x: fc.col * CELL + CELL / 2, y: fc.row * CELL + 14,
        'text-anchor': 'middle', 'dominant-baseline': 'middle',
        fill: initCfg ? (COLOUR_HEX[initCfg.colour] || initCfg.colour) : '#e05080',
        'font-size': '14px',
      });
      heart.textContent = '\u2665';
      layerOverlay.appendChild(heart);
    }
  }
}

function updatePawns() {
  layerPawns.innerHTML = '';
  // Group players by position
  const byPos = {};
  for (const p of game.players) {
    if (!byPos[p.position]) byPos[p.position] = [];
    byPos[p.position].push(p);
  }
  const offsets = {
    1: [[0, 0]],
    2: [[-10, 0], [10, 0]],
    3: [[-10, -7], [10, -7], [0, 10]],
    4: [[-10, -7], [10, -7], [-10, 10], [10, 10]],
  };
  for (const [posId, players] of Object.entries(byPos)) {
    const pos = positions[posId];
    if (!pos) continue;
    const offs = offsets[players.length] || offsets[4];
    for (let i = 0; i < players.length; i++) {
      const cfg = playerConfigs.find(c => c.id === players[i].id);
      const ox = offs[i] ? offs[i][0] : 0;
      const oy = offs[i] ? offs[i][1] : 0;
      const cx = pos.x + ox, cy = pos.y + oy;
      const colour = cfg ? (COLOUR_HEX[cfg.colour] || cfg.colour) : '#fff';
      const pawn = svgCreate('circle', {
        cx, cy, r: 11,
        fill: colour,
        class: 'pawn',
      });
      layerPawns.appendChild(pawn);
      // Player initial letter inside the pawn
      const initial = cfg ? cfg.name.charAt(0).toUpperCase() : '?';
      const label = svgCreate('text', {
        x: cx, y: cy,
        'text-anchor': 'middle', 'dominant-baseline': 'central',
        class: 'pawn-label',
      });
      label.textContent = initial;
      layerPawns.appendChild(label);
    }
  }
}

function highlightSpaces(ids, cls = 'highlight') {
  layerHighlight.innerHTML = '';
  for (const id of ids) {
    const cells = spaceIdToCells[id];
    if (!cells) continue;
    for (const cell of cells) {
      const r = svgCreate('rect', {
        x: cell.col * CELL, y: cell.row * CELL,
        width: CELL, height: CELL,
        class: cls,
      });
      layerHighlight.appendChild(r);
    }
  }
}
function clearHighlights() { layerHighlight.innerHTML = ''; }

// SVG helpers
function svgCreate(tag, attrs = {}) {
  const el = document.createElementNS(SVG_NS, tag);
  for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);
  return el;
}
function svgG(id) {
  const g = document.createElementNS(SVG_NS, 'g');
  if (id) g.id = id;
  return g;
}

// ═══════════════════════════════════════════════════════════════════════
//  UI HELPERS
// ═══════════════════════════════════════════════════════════════════════

function updateSidebar() {
  if (!game) return;
  const cp = game.getCurrentPlayer();
  const cfg = playerConfigs.find(c => c.id === cp.id);
  const colHex = COLOUR_HEX[cfg.colour] || cfg.colour;

  // Turn info
  document.getElementById('turn-info').innerHTML = `
    <div class="stat-row"><span class="label">Round</span><span class="value">${game.turnNumber}</span></div>
    <div class="stat-row"><span class="label">Max turns</span><span class="value">${game.config.maxTurns}</span></div>
  `;

  // Allies list
  let alliesHtml = '';
  if (cp.allies.length > 0) {
    const allyNames = cp.allies.map(aid => {
      const ac = playerConfigs.find(c => c.id === aid);
      return ac ? ac.name : aid;
    }).join(', ');
    alliesHtml = `<div class="stat-row"><span class="label">Allies</span><span class="value" style="color:#e05080">${allyNames}</span></div>`;
  }

  // Current player stats
  document.getElementById('current-player-stats').innerHTML = `
    <div class="stat-row" style="color:${colHex};font-weight:bold;font-size:14px">${cfg.name} (${ARCHETYPES[cfg.archetype].name})</div>
    <div class="stat-row stat-water"><span class="label">Water</span><span class="value">${cp.water} / ${ARCHETYPES[cp.archetype].water}</span></div>
    <div class="stat-row stat-swagger"><span class="label">Swagger</span><span class="value">${cp.swagger}</span></div>
    <div class="stat-row stat-drive"><span class="label">Drive</span><span class="value">${cp.drive}</span></div>
    <div class="stat-row stat-grit"><span class="label">Grit</span><span class="value">${cp.grit}</span></div>
    <div class="stat-row stat-bond"><span class="label">Bond</span><span class="value">${cp.bond}</span></div>
    ${alliesHtml}
    <div class="stat-row"><span class="label">Position</span><span class="value">${cp.position}</span></div>
  `;

  // All players summary
  let html = '';
  for (const p of game.players) {
    const c = playerConfigs.find(c => c.id === p.id);
    const cHex = COLOUR_HEX[c.colour] || c.colour;
    const terr = board.getTerritoriesOwnedBy(p.id).length;
    const isCurrent = p.id === cp.id ? ' current' : '';
    const allyDots = p.allies.length > 0 ? ` \u2665${p.allies.length}` : '';
    html += `<div class="player-summary${isCurrent}">
      <span class="ps-dot" style="background:${cHex}"></span>
      <span class="ps-name">${c.name}</span>
      <span class="ps-terr">${terr} T${allyDots}</span>
    </div>`;
  }
  document.getElementById('all-players-summary').innerHTML = html;
}

function setPhase(text) {
  document.getElementById('phase-banner').textContent = text;
}

function addLogEntry(text, cls = '') {
  const div = document.createElement('div');
  div.className = 'log-entry' + (cls ? ' ' + cls : '');
  div.textContent = text;
  const log = document.getElementById('game-log');
  log.appendChild(div);
  log.scrollTop = log.scrollHeight;
}

function showDice(d1, d2, total) {
  const dd = document.getElementById('dice-display');
  document.getElementById('die1').textContent = d1;
  document.getElementById('die2').textContent = d2;
  document.getElementById('die-total').textContent = total !== null ? total : '';
  dd.classList.add('visible');
}
function hideDice() {
  document.getElementById('dice-display').classList.remove('visible');
}

// Controls bar — dynamic buttons
function setControls(items) {
  const bar = document.getElementById('controls-bar');
  bar.innerHTML = '';
  for (const item of items) {
    if (item.type === 'info') {
      const span = document.createElement('span');
      span.className = 'ctrl-info';
      span.textContent = item.text;
      bar.appendChild(span);
    } else if (item.type === 'spacer') {
      const span = document.createElement('span');
      span.className = 'ctrl-spacer';
      bar.appendChild(span);
    } else if (item.type === 'button') {
      const btn = document.createElement('button');
      btn.className = 'ctrl-btn' + (item.cls ? ' ' + item.cls : '');
      btn.textContent = item.text;
      btn.addEventListener('click', () => {
        if (_resolveControlBtn) { _resolveControlBtn(item.value); _resolveControlBtn = null; }
      });
      bar.appendChild(btn);
    }
  }
}
function clearControls() { document.getElementById('controls-bar').innerHTML = ''; }

// ═══════════════════════════════════════════════════════════════════════
//  INTERACTION PROMISES
// ═══════════════════════════════════════════════════════════════════════

function waitForSpaceClick(validIds) {
  return new Promise((resolve) => {
    _validSpaceIds = validIds;
    _resolveSpaceClick = resolve;
  });
}

function waitForControl() {
  return new Promise((resolve) => { _resolveControlBtn = resolve; });
}

function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

// ═══════════════════════════════════════════════════════════════════════
//  ACTION HELPERS
// ═══════════════════════════════════════════════════════════════════════

function getActionableSpaces(player) {
  const result = [];
  const currentId = player.position;
  const neighbors = board.getNeighbors(currentId);
  const allTargets = [currentId, ...neighbors.map(n => n.space.id)];
  const seen = new Set();

  for (const tid of allTargets) {
    if (seen.has(tid)) continue; seen.add(tid);
    const s = board.getSpace(tid);
    if (!s) continue;
    const actions = [];

    if (s.type === SPACE_TYPES.TERRITORY) {
      if (s.owner === null && game.canClaim(player.id, tid).ok)
        actions.push({ type: 'claim', targetId: tid, label: `Claim ${s.label}`, cost: 'W:2 Sw:1' });
      if (s.owner && s.owner !== player.id && game.canChallenge(player.id, tid).ok)
        actions.push({ type: 'challenge', targetId: tid, label: `Challenge ${s.label}`, cost: 'W:2 Dr:1' });
      if (s.owner === player.id && game.canFortify(player.id, tid).ok)
        actions.push({ type: 'fortify', targetId: tid, label: `Fortify ${s.label}`, cost: 'W:1 Gr:1' });
    }
    if (s.type === SPACE_TYPES.DOG_PARK && game.canAlly(player.id, tid).ok) {
      actions.push({ type: 'ally', targetId: tid, label: `Ally at ${s.label}`, cost: 'W:1 Bd:1' });
    }
    if (s.type === SPACE_TYPES.WATER_SOURCE && game.canDrink(player.id).ok) {
      actions.push({ type: 'drink', targetId: tid, label: 'Drink', cost: 'Dr:1' });
    }

    if (actions.length > 0) result.push({ spaceId: tid, actions });
  }

  // PATH shortcut at current position
  const curSpace = board.getSpace(currentId);
  if (curSpace && curSpace.type === SPACE_TYPES.PATH && curSpace.pathExit && player.drive >= 1) {
    let entry = result.find(r => r.spaceId === currentId);
    if (!entry) { entry = { spaceId: currentId, actions: [] }; result.push(entry); }
    entry.actions.push({ type: 'shortcut', targetId: currentId, label: `Shortcut \u2192 ${curSpace.pathExit}`, cost: 'Dr:1' });
  }

  // Break alliance actions (attached to current position)
  for (const alliedId of player.allies) {
    if (game.canBreakAlliance(player.id, alliedId).ok) {
      const allyCfg = playerConfigs.find(c => c.id === alliedId);
      const allyName = allyCfg ? allyCfg.name : alliedId;
      let entry = result.find(r => r.spaceId === currentId);
      if (!entry) { entry = { spaceId: currentId, actions: [] }; result.push(entry); }
      entry.actions.push({ type: 'breakAlliance', targetId: alliedId, label: `Break alliance with ${allyName}`, cost: 'W:1 Sw:1' });
    }
  }

  return result;
}

// ═══════════════════════════════════════════════════════════════════════
//  GAME LOOP
// ═══════════════════════════════════════════════════════════════════════

async function runGame() {
  await delay(300);
  while (!game.gameOver) {
    game.startRound();
    addLogEntry(`=== Round ${game.turnNumber} ===`, 'round');
    updateSidebar();

    do {
      const player = game.getCurrentPlayer();
      const cfg = getConfig(player.id);
      addLogEntry(`--- ${cfg.name}'s turn ---`, 'system');
      updateSidebar();

      // Phase 1: Territory Income
      setPhase(`${cfg.name} — Income`);
      game.applyTerritoryIncome(player.id);
      flushEngineLog();
      updateSidebar();
      await delay(cfg.isAI ? 300 : 600);

      // Phase 2: Roll and Move
      setPhase(`${cfg.name} — Roll`);
      const d1 = Game.rollD6(), d2 = Game.rollD6();
      const maxSteps = d1 + d2;
      showDice(d1, d2, maxSteps);
      addLogEntry(`${cfg.name} rolled ${d1}+${d2} = ${maxSteps}`, 'system');
      await delay(cfg.isAI ? 600 : 1200);
      hideDice();

      setPhase(`${cfg.name} — Move`);
      let path;
      let _claudeResponse = null;
      if (cfg.isClaude) {
        setPhase(`${cfg.name} — Thinking...`);
        try {
          const result = await claudePlayerTurn(player, cfg, maxSteps);
          path = result.path;
          _claudeResponse = result.response;
        } catch (err) {
          addLogEntry(`  ${cfg.name}: Claude API error — falling back to algorithmic AI. (${err.message})`, 'system');
          path = aiComputePath(player, maxSteps);
          // _claudeResponse stays null — action phase will use algorithmic fallback
        }
        // Always animate and execute movement, even if action will fail later
        setPhase(`${cfg.name} — Move`);
        for (let i = 1; i < path.length; i++) {
          await delay(250);
          player.position = path[i];
          updatePawns();
        }
        player.position = path[0]; // reset for movePlayer
      } else if (cfg.isAI) {
        path = aiComputePath(player, maxSteps);
        // Animate AI movement step by step
        for (let i = 1; i < path.length; i++) {
          await delay(250);
          player.position = path[i]; // temp for visual
          updatePawns();
        }
        player.position = path[0]; // reset for movePlayer
      } else {
        path = await humanBuildPath(player, maxSteps);
      }

      const moveResult = game.movePlayer(player.id, path);
      flushEngineLog();
      updateOverlay();
      updatePawns();
      updateSidebar();

      // Process pass-through effects
      let passedHome = false;
      if (moveResult.success && moveResult.effects) {
        for (const eff of moveResult.effects) {
          if (eff.type === 'homeResupply') { passedHome = true; continue; }
          if (eff.type === 'dogPark') {
            game.applyDogPark(player.id);
            addLogEntry(`${cfg.name} passed Dog Park: +1 Bond`, 'action');
            updateSidebar();
          }
          if (eff.type === 'compulsoryBond') {
            const res = game.compulsoryBondJoin(player.id, eff.dogParkSpaceId);
            if (res.success) {
              addLogEntry(`${cfg.name} compulsory bond at ${eff.dogParkSpaceId}`, 'action');
              if (res.cleared && res.cleared.length > 0) {
                addLogEntry(`  Friendship sacrifice: cleared ${res.cleared.join(', ')}`, 'action');
              }
            }
            updateOverlay(); updateSidebar();
          }
          if (eff.type === 'pathEntry') {
            addLogEntry(`${cfg.name} at path entry (shortcut to ${eff.exitSpaceId} available)`, 'system');
          }
          if (eff.type === 'chanceCard') addLogEntry(`${cfg.name} passed Chance Spot (deck not implemented)`, 'system');
          if (eff.type === 'eventsCard') addLogEntry(`${cfg.name} passed Events (deck not implemented)`, 'system');
        }
      }

      // Phase 3: Action
      setPhase(`${cfg.name} — Action`);
      if (cfg.isClaude && _claudeResponse) {
        await delay(800);
        try {
          await executeClaudeAction(player, cfg, _claudeResponse);
        } catch (err) {
          addLogEntry(`  ${cfg.name}: Claude action error, skipping. (${err.message})`, 'system');
        }
      } else if (cfg.isAI) {
        await aiDoAction(player, cfg);
      } else {
        await humanDoAction(player, cfg);
      }
      clearControls();
      updateOverlay(); updatePawns(); updateSidebar();

      // Phase 4: Home Resupply
      if (passedHome) {
        game.applyHomeResupply(player.id);
        addLogEntry(`${cfg.name} resupplied at home`, 'action');
        updateSidebar();
      }

      // Phase 5: Win check
      const win = game.checkWinConditions();
      updateSidebar();
      if (win.gameOver) break;

      await delay(200);
    } while (game.advancePlayer());
  }

  showGameOver();
}

// ═══════════════════════════════════════════════════════════════════════
//  HUMAN INTERACTION
// ═══════════════════════════════════════════════════════════════════════

async function humanBuildPath(player, maxSteps) {
  const path = [player.position];
  let stepsLeft = maxSteps;
  let accDriveCost = 0;

  while (stepsLeft > 0) {
    const current = path[path.length - 1];
    const WALKABLE = ['sidewalk', 'intersection', 'sideStreet', 'path'];
    const reachable = board.getNeighbors(current).filter(n =>
      WALKABLE.includes(n.space.type) && !path.includes(n.space.id) && (accDriveCost + n.driveCost) <= player.drive
    );
    if (reachable.length === 0) break;

    highlightSpaces(reachable.map(n => n.space.id));
    setControls([
      { type: 'info', text: `Steps: ${stepsLeft} | Drive: ${player.drive - accDriveCost}` },
      { type: 'spacer' },
      { type: 'button', text: 'End Move', value: 'end', cls: 'primary' },
      path.length > 1 ? { type: 'button', text: 'Undo', value: 'undo', cls: 'warn' } : null,
    ].filter(Boolean));

    // Wait for either a space click or a control button
    const result = await Promise.race([
      waitForSpaceClick(reachable.map(n => n.space.id)).then(id => ({ type: 'space', id })),
      waitForControl().then(val => ({ type: 'ctrl', val })),
    ]);

    // Clear stale resolvers
    _resolveSpaceClick = null; _validSpaceIds = null; _resolveControlBtn = null;

    if (result.type === 'ctrl' && result.val === 'end') break;
    if (result.type === 'ctrl' && result.val === 'undo') {
      if (path.length > 1) {
        const removed = path.pop();
        const edge = board.getNeighbors(path[path.length - 1]).find(n => n.space.id === removed);
        if (edge) accDriveCost -= edge.driveCost;
        stepsLeft += 1;
        // Visual update
        player.position = path[path.length - 1];
        updatePawns();
      }
      continue;
    }
    if (result.type === 'space') {
      const edge = reachable.find(n => n.space.id === result.id);
      if (edge) {
        path.push(result.id);
        accDriveCost += edge.driveCost;
        stepsLeft -= 1;
        // Visual: move pawn as path builds
        player.position = result.id;
        updatePawns();
      }
    }
  }

  clearHighlights();
  clearControls();
  // Reset position so movePlayer can set it
  player.position = path[0];
  return path;
}

async function humanDoAction(player, cfg) {
  const actionable = getActionableSpaces(player);
  if (actionable.length === 0) {
    addLogEntry(`${cfg.name} has no available actions — passing.`, 'system');
    return;
  }

  // Show actionable spaces and controls
  const allIds = actionable.map(a => a.spaceId);
  highlightSpaces(allIds, 'highlight-action');

  while (true) {
    setControls([
      { type: 'info', text: 'Click a highlighted space or pass' },
      { type: 'spacer' },
      { type: 'button', text: 'Pass', value: 'pass', cls: '' },
    ]);

    const result = await Promise.race([
      waitForSpaceClick(allIds).then(id => ({ type: 'space', id })),
      waitForControl().then(val => ({ type: 'ctrl', val })),
    ]);
    _resolveSpaceClick = null; _validSpaceIds = null; _resolveControlBtn = null;

    if (result.type === 'ctrl' && result.val === 'pass') {
      addLogEntry(`${cfg.name} passes.`, 'system');
      break;
    }

    if (result.type === 'space') {
      const entry = actionable.find(a => a.spaceId === result.id);
      if (!entry) continue;

      // Show action buttons for this space
      const btns = entry.actions.map((a, i) => ({
        type: 'button', text: `${a.label} (${a.cost})`, value: String(i), cls: 'primary',
      }));
      btns.push({ type: 'spacer' });
      btns.push({ type: 'button', text: 'Back', value: 'back', cls: '' });
      setControls(btns);

      const actionResult = await waitForControl();
      _resolveControlBtn = null;

      if (actionResult === 'back') continue;

      const actionIdx = parseInt(actionResult);
      if (isNaN(actionIdx) || !entry.actions[actionIdx]) continue;

      const action = entry.actions[actionIdx];
      await executeAction(player, cfg, action);
      break;
    }
  }

  clearHighlights();
}

async function executeAction(player, cfg, action) {
  switch (action.type) {
    case 'claim': {
      game.claim(player.id, action.targetId);
      addLogEntry(`${cfg.name} claimed ${action.targetId}`, 'action');
      break;
    }
    case 'challenge': {
      await doChallenge(player, cfg, action.targetId);
      break;
    }
    case 'fortify': {
      game.fortify(player.id, action.targetId);
      addLogEntry(`${cfg.name} fortified ${action.targetId}`, 'action');
      break;
    }
    case 'ally': {
      game.ally(player.id, action.targetId);
      addLogEntry(`${cfg.name} initiated alliance at ${action.targetId}`, 'action');
      break;
    }
    case 'breakAlliance': {
      const allyCfg = getConfig(action.targetId);
      const allyName = allyCfg ? allyCfg.name : action.targetId;
      game.breakAlliance(player.id, action.targetId);
      addLogEntry(`${cfg.name} broke alliance with ${allyName}`, 'action');
      break;
    }
    case 'shortcut': {
      const res = game.takeShortcut(player.id, action.targetId);
      if (res.success) {
        addLogEntry(`${cfg.name} took shortcut \u2192 ${res.exitSpaceId}`, 'action');
      }
      break;
    }
    case 'drink': {
      const waterGain = 99; // tops up to archetype max
      game.drink(player.id, waterGain);
      addLogEntry(`${cfg.name} drank — water refilled`, 'action');
      break;
    }
  }
  flushEngineLog();
  updateOverlay(); updatePawns(); updateSidebar();
}

async function doChallenge(player, cfg, targetId) {
  const space = board.getSpace(targetId);
  const defId = space.owner;
  const defCfg = getConfig(defId);

  const payResult = game.payChallengeCost(player.id, targetId);
  if (!payResult.success) {
    addLogEntry(`Challenge failed: ${payResult.reason}`, 'challenge');
    return;
  }

  addLogEntry(`${cfg.name} challenges ${defCfg.name} at ${targetId}!`, 'challenge');
  updateSidebar();
  await delay(600);

  let result;
  do {
    const aRoll = Game.rollD6(), dRoll = Game.rollD6();
    showDice(aRoll, dRoll, null);
    await delay(900);
    hideDice();

    result = game.resolveChallenge(player.id, defId, targetId, aRoll, dRoll);
    addLogEntry(
      `  Attack ${result.attackRoll} \u2192 ${result.attackTotal}  vs  Defense ${result.defendRoll} \u2192 ${result.defendTotal}` +
      (result.fortifyBonus ? ` (+${result.fortifyBonus} fortify)` : '') +
      (result.clusterRule ? ' [cluster]' : ''),
      'challenge'
    );

    if (result.outcome === 'tie') {
      addLogEntry('  Tie! Re-rolling...', 'challenge');
      await delay(800);
    }
  } while (result.outcome === 'tie');

  if (result.outcome === 'attackerWins') {
    addLogEntry(`  ${cfg.name} wins!`, 'challenge');
    updateOverlay();

    // Re-claim choice
    const rc = game.canReClaim(player.id);
    if (rc.ok) {
      let useResource;
      if (cfg.isAI) {
        useResource = player.swagger >= 1 ? 'swagger' : (player.grit >= 1 ? 'grit' : null);
      } else {
        // Show re-claim choice
        const btns = [];
        if (player.swagger >= 1) btns.push({ type: 'button', text: 'Re-claim (Swagger)', value: 'swagger', cls: 'primary' });
        if (player.grit >= 1)    btns.push({ type: 'button', text: 'Re-claim (Grit)', value: 'grit', cls: 'primary' });
        btns.push({ type: 'spacer' });
        btns.push({ type: 'button', text: 'Decline', value: 'decline', cls: 'warn' });
        setControls(btns);
        useResource = await waitForControl();
        _resolveControlBtn = null;
        if (useResource === 'decline') useResource = null;
      }

      if (useResource) {
        game.reClaim(player.id, targetId, useResource);
        addLogEntry(`  ${cfg.name} re-claimed with ${useResource}`, 'action');
      } else {
        game.declineReClaim(targetId);
        addLogEntry(`  ${cfg.name} declined re-claim`, 'system');
      }
    } else {
      game.declineReClaim(targetId);
      addLogEntry(`  Cannot re-claim (no swagger or grit)`, 'system');
    }
  } else {
    addLogEntry(`  ${defCfg.name} defends!`, 'challenge');
  }

  flushEngineLog();
  updateOverlay(); updatePawns(); updateSidebar();
}

// ═══════════════════════════════════════════════════════════════════════
//  CLAUDE AI PLAYER
// ═══════════════════════════════════════════════════════════════════════

// ── BFS distances from a start space across the full board graph (all space types) ──

function bfsDistances(startId) {
  const dist = {};
  dist[startId] = 0;
  const queue = [startId];
  while (queue.length > 0) {
    const cur = queue.shift();
    const d = dist[cur];
    for (const n of board.getNeighbors(cur)) {
      if (dist[n.space.id] === undefined) {
        dist[n.space.id] = d + 1;
        queue.push(n.space.id);
      }
    }
  }
  return dist;
}

// ── Reachable walkable spaces within a dice roll (thin wrapper for prompt) ──

function getReachableSpaces(player, maxSteps) {
  const reachable = bfsReachable(player, maxSteps);
  const result = [];
  for (const [id, info] of reachable) {
    result.push({ id, steps: info.steps, driveCost: info.driveCost });
  }
  return result;
}

function buildPrompt(player, maxSteps) {
  const arch = ARCHETYPES[player.archetype];
  const myTerritories = board.getTerritoriesOwnedBy(player.id);
  const allSpaces = board.getAllSpaces();
  const myName = getConfig(player.id).name;

  // Only include territories that are claimed or reachable this turn
  const reachable = getReachableSpaces(player, maxSteps);
  const reachableIds = new Set(reachable.map(r => r.id));
  const reachableNeighborIds = new Set(
    reachable.flatMap(r => board.getNeighbors(r.id).map(n => n.space.id))
  );

  const relevantTerritories = allSpaces
    .filter(s => s.type === SPACE_TYPES.TERRITORY &&
      (s.owner !== null || reachableNeighborIds.has(s.id)))
    .map(s => {
      const ownerCfg = s.owner ? getConfig(s.owner) : null;
      return `  ${s.id}: ${s.owner ? ownerCfg.name : 'empty'}${s.fortifyTokens ? ' (fortified)' : ''}`;
    }).join('\n');

  const waterSources = allSpaces
    .filter(s => s.type === SPACE_TYPES.WATER_SOURCE)
    .map(s => s.id).join(', ');

  const dogParks = allSpaces
    .filter(s => s.type === SPACE_TYPES.DOG_PARK)
    .map(s => `${s.id}${game.pendingAlliances.has(s.id) ? ' (active bond)' : ''}`).join(', ');

  const homeTurfs = game.players
    .map(p => {
      const cfg = getConfig(p.id);
      const hs = board.getHomeSpace(p.id, game.players);
      return `${cfg.name}: ${hs?.id ?? 'unknown'}`;
    }).join(', ');

  const otherPlayers = game.players
    .filter(p => p.id !== player.id)
    .map(p => {
      const cfg = getConfig(p.id);
      const tc = board.getTerritoriesOwnedBy(p.id).length;
      return `  ${cfg.name} (${p.archetype}): ${tc} territories, W:${p.water} Sw:${p.swagger} Dr:${p.drive} Gr:${p.grit} Bd:${p.bond}, at ${p.position}`;
    }).join('\n');

  // Home turf: find the walkable sidewalk adjacent to this player's home + BFS distance
  const homeSpace = board.getHomeSpace(player.id, game.players);
  const homeSidewalks = homeSpace
    ? board.getNeighbors(homeSpace.id)
        .filter(n => WALKABLE.includes(n.space.type))
        .map(n => n.space.id)
    : [];
  const homeSidewalk = homeSidewalks[0] || null;
  const distances = bfsDistances(player.position);
  const homeSidewalkDist = homeSidewalk ? (distances[homeSidewalk] ?? 999) : 999;

  const reachableList = reachable.map(r => {
    const adj = board.getNeighbors(r.id)
      .filter(n => [SPACE_TYPES.TERRITORY, SPACE_TYPES.HOME,
        SPACE_TYPES.DOG_PARK, SPACE_TYPES.WATER_SOURCE].includes(n.space.type))
      .map(n => {
        const s = n.space;
        if (s.type === SPACE_TYPES.TERRITORY) {
          const ownerCfg = s.owner ? getConfig(s.owner) : null;
          return `${s.id}(${s.owner ? ownerCfg.name : 'EMPTY'}${s.fortifyTokens ? ',fortified' : ''})`;
        }
        if (s.type === SPACE_TYPES.WATER_SOURCE) return `${s.id}(WATER SOURCE)`;
        if (s.type === SPACE_TYPES.HOME) {
          const isYours = game.players.find(
            p2 => board.getHomeSpace(p2.id, game.players)?.id === s.id
          )?.id === player.id;
          return `${s.id}(${isYours ? 'YOUR HOME \u2014 full resupply' : 'opponent home'})`;
        }
        if (s.type === SPACE_TYPES.DOG_PARK)
          return `${s.id}(dog park${game.pendingAlliances.has(s.id) ? ',active bond' : ''})`;
      }).filter(Boolean).join(', ');
    return `  ${r.id}${adj ? ': ' + adj : ''}`;
  }).join('\n');

  return `# Uri-Nation Rules

You are playing Uri-Nation. Your goal is to WIN by holding the most territory.

## Win Conditions
1. Hold 15 non-home territories at end of any turn.
2. Last player with non-home territory.
3. After 30 rounds: most territory wins. Ties: fortify tokens, then swagger.

## The Board
You walk on sidewalk and intersection spaces only. Territories, home turfs, dog parks, and water sources are ADJACENT to sidewalks \u2014 you never step on them, you interact from the sidewalk beside them.

## Movement
Your roll is already done (see below). Move along connected sidewalk/intersection spaces up to your roll. You can stop early or backtrack.

## Resources in your dog bowl
- Water pegs (rim) \u2014 fuel for all pee-based actions
- Swagger, Drive, Grit, Bond tokens (centre)

## Actions (at stopping position, targeting adjacent space)
| Action | Cost | Effect |
|--------|------|--------|
| Claim | 2 water + 1 swagger | Mark an EMPTY adjacent territory |
| Challenge | 2 water + 1 drive | Contest opponent's adjacent territory. Both roll 1d6 \u2014 attacker must roll higher. Defender +1 if fortified. If defender has 3+ connected territories, ties go to defender. Win: spend 1 swagger OR 1 grit to convert to your claim (if neither available, territory sits empty). Lose: +1 grit to you. |
| Fortify | 1 water + 1 grit | Add defence to YOUR adjacent territory (max 1 token) |
| Ally | 1 water + 1 bond | Initiate alliance at adjacent dog park. Protects both players' 2 home-adjacent territories from each other. Clears any claims either holds in other's home neighbourhood. |
| Drink | 1 drive | At adjacent water source \u2014 tops up water to your max ONLY. Does not restore swagger/drive/grit/bond. Can happen during movement without ending your turn. |
| None | \u2014 | No action this turn |

## Home Turf \u2014 IMPORTANT
Stopping at your home turf's adjacent sidewalk triggers FULL RESUPPLY: water AND swagger AND drive AND grit AND bond all refilled to your archetype max. This is the ONLY way to restore swagger, drive, and bond. Costs remaining movement.

## Archetype Maximums
| | Water | Swagger | Drive | Grit | Bond |
|-|-------|---------|-------|------|------|
| Bruiser | 6 | 3 | 2 | 2 | 1 |
| Scrapper | 3 | 2 | 3 | 1 | 2 |
| Diplomat | 4 | 2 | 1 | 2 | 3 |
| Yapper | 4 | 1 | 2 | 3 | 2 |

## Territory Income
Start of each turn: +1 swagger per 3 connected territories you own.

---

# Game State \u2014 Round ${game.turnNumber} of 30

**Claimed and reachable territories:**
${relevantTerritories || '  none near you'}

**Water sources (board-wide):** ${waterSources}
**Dog parks:** ${dogParks}
**Home turfs:** ${homeTurfs}

**Other players:**
${otherPlayers}

---

# Your Turn \u2014 ${myName} (${player.archetype})

Resources: Water:${player.water}/${arch.water} Swagger:${player.swagger} Drive:${player.drive} Grit:${player.grit} Bond:${player.bond}
Territories (${myTerritories.length}): ${myTerritories.map(t => t.id).join(', ') || 'none'}
Position: ${player.position}
Your home turf: ${homeSpace?.id ?? 'unknown'}, accessible from ${homeSidewalk || 'unknown'} (stop here to resupply everything)
Distance to your home turf sidewalk: ${homeSidewalkDist} steps
Roll: ${maxSteps} steps this turn
Allies: ${player.allies?.length > 0 ? player.allies.map(id => getConfig(id).name).join(', ') : 'none'}

**Spaces reachable this turn:**
${reachableList || '  none'}

Decide your best move to win the game. Consider what you can afford now and what you need to set up for future turns. If swagger is 0, you cannot claim \u2014 your priority should be reaching your home turf to resupply.

Respond with JSON only:
{
  "moveTo": "id from reachable list above",
  "action": "claim|challenge|fortify|ally|drink|none",
  "actionTarget": "space id or null",
  "plan": "next 2-3 turn strategy",
  "reasoning": "why this maximises your territory"
}`;
}

async function callClaudeAPI(messages) {
  const apiKey = sessionStorage.getItem('anthropic_api_key');
  if (!apiKey) throw new Error('No API key configured');

  const resp = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': apiKey,
      'anthropic-version': '2023-06-01',
      'anthropic-dangerous-direct-browser-access': 'true',
    },
    body: JSON.stringify({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 512,
      messages,
    }),
  });

  if (!resp.ok) {
    const errText = await resp.text().catch(() => '');
    throw new Error(`API ${resp.status}: ${errText.slice(0, 200)}`);
  }
  const data = await resp.json();
  return data.content[0].text;
}

function getActionsAtPosition(player, spaceId) {
  const savedPos = player.position;
  player.position = spaceId;
  const actions = getActionableSpaces(player);
  player.position = savedPos;
  return actions;
}

function parseClaudeResponse(text) {
  // Extract outermost {...} block regardless of surrounding prose
  const raw = (text || '').trim();
  const start = raw.indexOf('{');
  const end = raw.lastIndexOf('}');
  if (start === -1 || end === -1) throw new Error('No JSON found in response');
  return JSON.parse(raw.slice(start, end + 1));
}

async function claudePlayerTurn(player, cfg, maxSteps) {
  // Build prompt (computes reachable internally)
  const promptText = buildPrompt(player, maxSteps);
  const messages = [{ role: 'user', content: promptText }];

  // Call Claude API
  const rawResponse = await callClaudeAPI(messages);
  const response = parseClaudeResponse(rawResponse);

  // Validate moveTo against BFS reachable
  const reachable = bfsReachable(player, maxSteps);
  const moveTo = response.moveTo;
  if (!moveTo || !reachable.has(moveTo)) {
    throw new Error(`Invalid moveTo: ${moveTo}`);
  }

  // Build path
  const path = reconstructPath(reachable, moveTo);
  if (path.length === 0 || path[0] !== player.position) {
    throw new Error(`Path reconstruction failed for ${moveTo}`);
  }

  return { path, response };
}

async function executeClaudeAction(player, cfg, claudeResponse) {
  const { action, actionTarget, reasoning, plan } = claudeResponse;

  // Log reasoning and plan (to DOM and engine log for export)
  if (reasoning) {
    addLogEntry(`  ${cfg.name} thinks: "${reasoning}"`, 'reasoning');
    game._log(player.id, `[reasoning] ${reasoning}`);
  }
  if (plan) {
    addLogEntry(`  ${cfg.name} plans: "${plan}"`, 'reasoning');
    game._log(player.id, `[reasoning] plan: ${plan}`);
  }

  if (!action || action === 'pass' || action === 'none') {
    addLogEntry(`${cfg.name} (Claude AI): passes.`, 'system');
    return;
  }

  // Find matching action from current actionable spaces
  const actionable = getActionableSpaces(player);
  const allActions = actionable.flatMap(a => a.actions);

  let matched = null;
  if (actionTarget) {
    matched = allActions.find(a => a.type === action && a.targetId === actionTarget);
  }
  if (!matched) {
    matched = allActions.find(a => a.type === action);
  }

  if (matched) {
    await executeAction(player, cfg, matched);
  } else if (allActions.length > 0) {
    // Claude chose an unavailable action — try the same type without target match
    addLogEntry(`  ${cfg.name}: "${action} ${actionTarget || ''}" not available here, skipping action.`, 'system');
  } else {
    addLogEntry(`  ${cfg.name}: no actions at this position.`, 'system');
  }
}

// ═══════════════════════════════════════════════════════════════════════
//  AI PLAYER — ALGORITHMIC FALLBACK (goal-directed, priority-driven)
// ═══════════════════════════════════════════════════════════════════════

const WALKABLE = ['sidewalk', 'intersection', 'sideStreet', 'path'];
const aiStuckTurns = {};   // playerId → consecutive turns stuck with no action
const aiLastPosition = {}; // playerId → position last turn

// ── BFS within movement range (walkable spaces only) ──

function bfsReachable(player, maxSteps) {
  const reachable = new Map();
  const queue = [[player.position, 0, 0, null]];
  reachable.set(player.position, { steps: 0, driveCost: 0, parent: null });

  while (queue.length > 0) {
    const [curId, steps, drCost] = queue.shift();
    if (steps >= maxSteps) continue;

    for (const n of board.getNeighbors(curId)) {
      if (!WALKABLE.includes(n.space.type)) continue;
      const nId = n.space.id;
      const newDrive = drCost + n.driveCost;
      if (newDrive > player.drive) continue;
      const newSteps = steps + 1;
      const existing = reachable.get(nId);
      if (!existing || newSteps < existing.steps || (newSteps === existing.steps && newDrive < existing.driveCost)) {
        reachable.set(nId, { steps: newSteps, driveCost: newDrive, parent: curId });
        queue.push([nId, newSteps, newDrive, curId]);
      }
    }
  }
  return reachable;
}

function reconstructPath(reachable, targetId) {
  const path = [];
  let cur = targetId;
  while (cur !== null) {
    path.unshift(cur);
    const info = reachable.get(cur);
    if (!info) break;
    cur = info.parent;
  }
  return path;
}

// ── Find the walkable sidewalk(s) adjacent to a player's home ──

function getHomeSidewalks(player) {
  const homeSpace = board.getHomeSpace(player.id, game.players);
  if (!homeSpace) return [];
  return board.getNeighbors(homeSpace.id)
    .filter(n => WALKABLE.includes(n.space.type))
    .map(n => n.space.id);
}

// ── BFS shortest path toward a target space (across full board, walkable only) ──

function bfsTowardTarget(player, maxSteps, targetIds) {
  const reachable = bfsReachable(player, maxSteps);
  // Find the reachable space that is closest to any targetId
  let bestDest = null;
  let bestDist = Infinity;

  for (const [destId] of reachable) {
    if (destId === player.position) continue;
    if (targetIds.includes(destId)) {
      // We can reach the target directly
      return reconstructPath(reachable, destId);
    }
    // BFS from destId toward targets (full graph)
    const visited = new Set([destId]);
    const queue = [[destId, 0]];
    while (queue.length > 0) {
      const [cur, d] = queue.shift();
      if (d >= bestDist) break; // Can't improve
      if (targetIds.includes(cur)) {
        bestDist = d;
        bestDest = destId;
        break;
      }
      for (const nb of board.getNeighbors(cur)) {
        if (!visited.has(nb.space.id)) {
          visited.add(nb.space.id);
          queue.push([nb.space.id, d + 1]);
        }
      }
    }
  }

  if (bestDest) {
    const path = reconstructPath(reachable, bestDest);
    if (path.length > 0 && path[0] === player.position) return path;
  }
  return [player.position];
}

// ── Score a walkable destination by what's adjacent to it ──

function scoreWalkableDest(player, destId, steps) {
  const arch = ARCHETYPES[player.archetype];
  const neighbors = board.getNeighbors(destId);
  let score = 0;

  // Penalty for staying put — prefer moving somewhere new
  if (destId === player.position) score -= 8;

  for (const n of neighbors) {
    const s = n.space;
    if (s.type === SPACE_TYPES.TERRITORY) {
      if (s.owner === null) {
        // Unclaimed territory — high priority if we can claim
        if (player.water >= 2 && player.swagger >= 1) score += 10;
        else score += 2; // Still worth moving near for later
      } else if (s.owner !== player.id && !player.allies.includes(s.owner)) {
        // Opponent territory — worth challenging if affordable
        if (player.water >= 2 && player.drive >= 1) score += 5;
        else score += 1;
      } else if (s.owner === player.id && s.fortifyTokens < game.config.maxFortify) {
        // Own territory, can fortify
        if (player.water >= 1 && player.grit >= 1) score += 3;
      }
    }
    if (s.type === SPACE_TYPES.WATER_SOURCE && player.water < arch.water) {
      // Water source — urgent if low water
      if (player.water <= 1) score += 15;
      else if (player.water <= Math.ceil(arch.water / 2)) score += 8;
      else score += 2;
    }
    if (s.type === SPACE_TYPES.HOME && s.playerColour === player.colour) {
      // Own home — resupply value (high when any resource is depleted)
      const needsHome = player.swagger === 0 || player.water < 2 || player.drive === 0;
      if (needsHome) score += 20;
      else {
        const deficit = (arch.water - player.water) + (arch.swagger - player.swagger) +
                        (arch.drive - player.drive);
        if (deficit >= 3) score += 6;
        else score += 1;
      }
    }
    if (s.type === SPACE_TYPES.DOG_PARK) {
      if (player.water >= 1 && player.bond >= 1) score += 2;
    }
  }

  // Slight distance penalty to prefer closer goals
  score -= steps * 0.2;
  return score;
}

// ── Goal-directed AI movement ──

function aiComputePath(player, maxSteps) {
  // Stuck escape: if stuck for 2+ turns, force movement toward home
  const stuck = aiStuckTurns[player.id] || 0;
  if (stuck >= 2) {
    const homeSidewalks = getHomeSidewalks(player);
    if (homeSidewalks.length > 0) {
      return bfsTowardTarget(player, maxSteps, homeSidewalks);
    }
  }

  const reachable = bfsReachable(player, maxSteps);

  let bestScore = -Infinity;
  let bestDest = player.position;

  for (const [destId, info] of reachable) {
    const score = scoreWalkableDest(player, destId, info.steps);
    if (score > bestScore) {
      bestScore = score;
      bestDest = destId;
    }
  }

  // If nothing scored well, move toward home sidewalk
  if (bestScore <= 0) {
    const homeSidewalks = getHomeSidewalks(player);
    if (homeSidewalks.length > 0) {
      return bfsTowardTarget(player, maxSteps, homeSidewalks);
    }
  }

  if (bestDest === player.position) return [player.position];

  const path = reconstructPath(reachable, bestDest);
  if (path.length === 0 || path[0] !== player.position) return [player.position];
  return path;
}

// ── Priority-driven AI action selection ──

async function aiDoAction(player, cfg) {
  await delay(400);

  // Track stuck state — detect position change
  const prevPos = aiLastPosition[player.id];
  if (player.position !== prevPos) {
    aiStuckTurns[player.id] = 0;
  }
  aiLastPosition[player.id] = player.position;

  const actionable = getActionableSpaces(player);
  const allActions = actionable.flatMap(a => a.actions);
  if (allActions.length === 0) {
    addLogEntry(`${cfg.name} (AI): no actions available.`, 'system');
    aiStuckTurns[player.id] = (aiStuckTurns[player.id] || 0) + 1;
    return;
  }

  const arch = ARCHETYPES[player.archetype];

  // Priority 1: Drink if water below max and a drink action is available
  if (player.water < arch.water) {
    const drink = allActions.find(a => a.type === 'drink');
    if (drink) { await executeAction(player, cfg, drink); aiStuckTurns[player.id] = 0; return; }
  }

  // Priority 2: Claim any available territory
  const claim = allActions.find(a => a.type === 'claim');
  if (claim) { await executeAction(player, cfg, claim); aiStuckTurns[player.id] = 0; return; }

  // Priority 3: Challenge an opponent territory
  const challenge = allActions.find(a => a.type === 'challenge');
  if (challenge) { await executeAction(player, cfg, challenge); aiStuckTurns[player.id] = 0; return; }

  // Priority 4: Fortify an owned territory
  const fortify = allActions.find(a => a.type === 'fortify');
  if (fortify) { await executeAction(player, cfg, fortify); aiStuckTurns[player.id] = 0; return; }

  // Priority 5: Ally at a dog park
  const ally = allActions.find(a => a.type === 'ally');
  if (ally) { await executeAction(player, cfg, ally); aiStuckTurns[player.id] = 0; return; }

  // Priority 6: Take a shortcut
  const shortcut = allActions.find(a => a.type === 'shortcut');
  if (shortcut) { await executeAction(player, cfg, shortcut); aiStuckTurns[player.id] = 0; return; }

  addLogEntry(`${cfg.name} (AI): no affordable actions.`, 'system');
  aiStuckTurns[player.id] = (aiStuckTurns[player.id] || 0) + 1;
}

// ═══════════════════════════════════════════════════════════════════════
//  GAME OVER
// ═══════════════════════════════════════════════════════════════════════

function showGameOver() {
  setPhase('Game Over');
  const winCfg = getConfig(game.winner);
  document.getElementById('go-title').textContent = `${winCfg.name} Wins!`;

  // Build ranking
  const ranked = [...game.players].sort((a, b) =>
    board.getTerritoriesOwnedBy(b.id).length - board.getTerritoriesOwnedBy(a.id).length
  );
  const detail = ranked.map((p, i) => {
    const c = getConfig(p.id);
    const terr = board.getTerritoriesOwnedBy(p.id).length;
    return `${i + 1}. ${c.name} (${ARCHETYPES[c.archetype].name}) \u2014 ${terr} territories`;
  }).join('\n');
  document.getElementById('go-detail').textContent = detail;
  document.getElementById('go-detail').style.whiteSpace = 'pre-line';
  document.getElementById('game-over').classList.add('visible');
}

function exportLog() {
  const lines = [];
  // Header
  lines.push('Uri-Nation Game Log');
  lines.push('='.repeat(40));
  lines.push(`Date: ${new Date().toISOString()}`);
  lines.push(`Rounds: ${game.turnNumber}`);
  lines.push(`Winner: ${getConfig(game.winner)?.name || game.winner}`);
  lines.push('');
  // Players
  lines.push('Players:');
  for (const p of game.players) {
    const c = getConfig(p.id);
    const terr = board.getTerritoriesOwnedBy(p.id).length;
    lines.push(`  ${c.name} (${ARCHETYPES[c.archetype].name}) — ${terr} territories, W:${p.water} Sw:${p.swagger} Dr:${p.drive} Gr:${p.grit} Bd:${p.bond}`);
  }
  lines.push('');
  // Full engine log
  lines.push('Game Log:');
  lines.push('-'.repeat(40));
  for (const entry of game.log) {
    const prefix = entry.player ? `[${getConfig(entry.player)?.name || entry.player}] ` : '';
    lines.push(`R${entry.turn} ${prefix}${entry.message}`);
  }

  const blob = new Blob([lines.join('\n')], { type: 'text/plain' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `game-log-${new Date().toISOString().slice(0,10)}.txt`;
  a.click();
  URL.revokeObjectURL(a.href);
}

// ═══════════════════════════════════════════════════════════════════════
//  MISC HELPERS
// ═══════════════════════════════════════════════════════════════════════

function getConfig(playerId) {
  return playerConfigs.find(c => c.id === playerId);
}

let lastLogIdx = 0;
function flushEngineLog() {
  while (lastLogIdx < game.log.length) {
    const entry = game.log[lastLogIdx];
    const prefix = entry.player ? `[${getConfig(entry.player)?.name || entry.player}] ` : '';
    lastLogIdx++;
  }
}

// ═══════════════════════════════════════════════════════════════════════
//  INIT
// ═══════════════════════════════════════════════════════════════════════

document.addEventListener('DOMContentLoaded', () => {
  initSetup();
  buildPlayerConfigRows(2);
});
</script>
</body>
</html>
