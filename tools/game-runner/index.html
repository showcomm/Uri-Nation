<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Uri-Nation — Game Runner</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: #1a1a2e;
  color: #e0e0e0;
  height: 100vh;
  overflow: hidden;
}

/* ── Setup Screen ─────────────────────────────────── */
#setup-screen {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100vh;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
}
.setup-panel {
  background: #16213e;
  border: 1px solid #333;
  border-radius: 12px;
  padding: 32px 40px;
  width: 520px;
  max-height: 90vh;
  overflow-y: auto;
}
.setup-panel h1 { font-size: 28px; color: #e8d44d; margin-bottom: 4px; }
.setup-panel h2 { font-size: 14px; color: #888; font-weight: normal; margin-bottom: 24px; }
.setup-section { margin-bottom: 20px; }
.setup-section > label { display: block; font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; }
.setup-section input[type="file"] { font-size: 13px; color: #ccc; }
#board-info { font-size: 12px; color: #6a6; margin-top: 6px; min-height: 18px; }
#board-info.error { color: #c66; }
.player-count-btns { display: flex; gap: 8px; margin-bottom: 12px; }
.player-count-btns button {
  padding: 6px 18px; background: #1a1a2e; border: 1px solid #555; border-radius: 4px;
  color: #ccc; cursor: pointer; font-size: 13px;
}
.player-count-btns button.active { border-color: #4488cc; color: #fff; background: #0f3460; }
.player-row {
  display: grid;
  grid-template-columns: 30px 1fr 1fr 80px;
  gap: 8px;
  align-items: center;
  margin-bottom: 8px;
}
.player-row .player-dot { width: 18px; height: 18px; border-radius: 50%; }
.player-row input, .player-row select {
  padding: 5px 8px; background: #1a1a2e; border: 1px solid #555; border-radius: 4px;
  color: #fff; font-size: 12px;
}
.player-row select { cursor: pointer; }
.big-btn {
  display: block; width: 100%; padding: 12px; margin-top: 16px;
  background: #0f3460; border: 2px solid #4488cc; border-radius: 8px;
  color: #bbd; font-size: 16px; cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
}
.big-btn:hover:not(:disabled) { background: #1a4a80; color: #fff; }
.big-btn:disabled { opacity: 0.4; cursor: default; }

/* ── Game Screen ──────────────────────────────────── */
#game-screen {
  display: none;
  height: 100vh;
  grid-template-columns: 240px 1fr 260px;
  grid-template-rows: 1fr;
}
#game-screen.visible { display: grid; }

/* Sidebar */
#sidebar {
  background: #16213e;
  border-right: 1px solid #333;
  padding: 12px;
  overflow-y: auto;
  min-height: 0;
}
#sidebar h3 {
  font-size: 11px; text-transform: uppercase; letter-spacing: 1px;
  color: #666; margin: 12px 0 6px;
}
#sidebar h3:first-child { margin-top: 0; }
#phase-banner {
  text-align: center; padding: 4px 12px; font-size: 12px; font-weight: bold;
  color: #e8d44d; text-transform: uppercase; letter-spacing: 2px; background: #0f3460;
  border-bottom: 1px solid #333;
}
.stat-row { display: flex; justify-content: space-between; font-size: 13px; padding: 3px 0; }
.stat-row .label { color: #999; }
.stat-row .value { color: #fff; font-weight: bold; min-width: 30px; text-align: right; }
.stat-water .value { color: #40a0e0; }
.stat-swagger .value { color: #e8d44d; }
.stat-drive .value { color: #e07040; }
.stat-grit .value { color: #a0a0b0; }
.stat-bond .value { color: #e05080; }
.player-summary {
  display: flex; align-items: center; gap: 8px;
  padding: 5px 6px; border-radius: 4px; margin-bottom: 4px; font-size: 12px;
}
.player-summary.current { background: rgba(255,255,255,0.08); }
.player-summary .ps-dot { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; }
.player-summary .ps-name { flex: 1; }
.player-summary .ps-terr { color: #7ec850; font-weight: bold; }

/* Board area */
#board-area {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background: #1a1a2e;
}
#board-container {
  flex: 1;
  overflow: auto;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 12px;
  position: relative;
}
#board-svg { cursor: default; }
#board-svg .cell-rect { stroke: rgba(0,0,0,0.15); stroke-width: 0.5; }
#board-svg .cell-interactive { cursor: pointer; }
#board-svg .cell-interactive:hover { stroke: rgba(255,255,255,0.4); stroke-width: 1.5; }
#board-svg .highlight { fill: rgba(0,128,255,0.25); stroke: #0080ff; stroke-width: 2; pointer-events: none; }
#board-svg .highlight-action { fill: rgba(255,200,0,0.2); stroke: #ffc800; stroke-width: 2; pointer-events: none; }
#board-svg .pawn { stroke: #000; stroke-width: 1.5; }
#board-svg .fortify-dot { fill: #fff; stroke: #333; stroke-width: 0.5; }
#board-svg .owner-border { fill: none; stroke-width: 2.5; pointer-events: none; }

/* Controls bar */
#controls-bar {
  display: flex; align-items: center; gap: 12px;
  padding: 8px 16px; background: #0f3460; border-top: 1px solid #333;
  min-height: 48px; flex-wrap: wrap;
}
#controls-bar .ctrl-btn {
  padding: 5px 14px; background: #16213e; border: 1px solid #4488cc; border-radius: 4px;
  color: #bbd; font-size: 12px; cursor: pointer;
}
#controls-bar .ctrl-btn:hover { background: #1a4a80; color: #fff; }
#controls-bar .ctrl-btn.warn { border-color: #cc4444; color: #c88; }
#controls-bar .ctrl-btn.primary { border-color: #44cc88; color: #8dc; }
#controls-bar .ctrl-info { font-size: 13px; color: #aab; }
#controls-bar .ctrl-spacer { flex: 1; }

/* Dice */
#dice-display {
  display: none;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 100;
  gap: 12px;
  align-items: center;
  pointer-events: none;
}
#dice-display.visible { display: flex; }
.die {
  width: 48px; height: 48px; background: #fff; border-radius: 8px;
  display: flex; align-items: center; justify-content: center;
  font-size: 28px; font-weight: bold; color: #222;
  box-shadow: 3px 3px 8px rgba(0,0,0,0.5);
}
.die-eq { font-size: 20px; color: #fff; }
.die-total { font-size: 32px; font-weight: bold; color: #e8d44d; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }

/* Log panel */
#log-panel {
  background: #16213e;
  border-left: 1px solid #333;
  display: flex;
  flex-direction: column;
  min-height: 0;
}
#log-panel h3 {
  font-size: 11px; text-transform: uppercase; letter-spacing: 1px;
  color: #666; padding: 12px 12px 6px;
}
#game-log {
  flex: 1; overflow-y: auto; padding: 0 12px 12px; font-size: 12px; font-family: monospace;
}
.log-entry { padding: 2px 0; color: #999; border-bottom: 1px solid rgba(255,255,255,0.03); }
.log-entry.round { color: #e8d44d; font-weight: bold; margin-top: 8px; }
.log-entry.action { color: #7ec850; }
.log-entry.challenge { color: #e07040; }
.log-entry.system { color: #4488cc; }

/* Game over overlay */
#game-over {
  display: none;
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.7);
  z-index: 200;
  align-items: center;
  justify-content: center;
}
#game-over.visible { display: flex; }
#game-over .go-panel {
  background: #16213e; border: 2px solid #e8d44d; border-radius: 12px;
  padding: 32px 48px; text-align: center;
}
#game-over h2 { font-size: 32px; color: #e8d44d; margin-bottom: 8px; }
#game-over p { font-size: 16px; color: #ccc; margin-bottom: 24px; }
</style>
</head>
<body>

<!-- ── Setup Screen ──────────────────────────────── -->
<div id="setup-screen">
  <div class="setup-panel">
    <h1>Uri-Nation</h1>
    <h2>Game Runner</h2>

    <div class="setup-section">
      <label>Load Board JSON</label>
      <input type="file" id="board-file" accept=".json" />
      <div id="board-info"></div>
    </div>

    <div class="setup-section" id="player-setup" style="display:none">
      <label>Players</label>
      <div class="player-count-btns" id="count-btns"></div>
      <div id="player-configs"></div>
    </div>

    <button id="btn-start" class="big-btn" disabled>Start Game</button>
  </div>
</div>

<!-- ── Game Screen ───────────────────────────────── -->
<div id="game-screen">
  <div id="sidebar">
    <h3>Turn</h3>
    <div id="turn-info"></div>
    <h3>Current Player</h3>
    <div id="current-player-stats"></div>
    <h3>All Players</h3>
    <div id="all-players-summary"></div>
  </div>

  <div id="board-area">
    <div id="phase-banner">Setup</div>
    <div id="board-container">
      <svg id="board-svg" xmlns="http://www.w3.org/2000/svg"></svg>
      <div id="dice-display">
        <div class="die" id="die1"></div>
        <div class="die" id="die2"></div>
        <span class="die-eq">=</span>
        <span class="die-total" id="die-total"></span>
      </div>
    </div>
    <div id="controls-bar"></div>
  </div>

  <div id="log-panel">
    <h3>Game Log</h3>
    <div id="game-log"></div>
  </div>
</div>

<!-- ── Game Over Overlay ─────────────────────────── -->
<div id="game-over">
  <div class="go-panel">
    <h2 id="go-title"></h2>
    <p id="go-detail"></p>
    <button class="big-btn" onclick="exportLog()" style="border-color:#44cc88;color:#8dc;margin-bottom:8px">Export Log</button>
    <button class="big-btn" onclick="location.reload()">New Game</button>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════════
//  INLINED ENGINE (from tools/engine/ — v1.3.0)
//  Copied here so the file works standalone via file:// protocol.
// ═══════════════════════════════════════════════════════════════════════

// --- archetypes.js ---

const ARCHETYPES = {
  bruiser:  { name: 'Bruiser',  water: 6, swagger: 3, drive: 2, grit: 2, bond: 1, discount: 'claimNoSwagger' },
  scrapper: { name: 'Scrapper', water: 3, swagger: 2, drive: 3, grit: 1, bond: 2, discount: 'drinkNoDrive' },
  diplomat: { name: 'Diplomat', water: 4, swagger: 2, drive: 1, grit: 2, bond: 3, discount: 'allyNoBond' },
  yapper:   { name: 'Yapper',  water: 4, swagger: 1, drive: 2, grit: 3, bond: 2, discount: 'fortifyNoGrit' },
};

// --- board.js ---

const SPACE_TYPES = {
  SIDEWALK:     'sidewalk',
  TERRITORY:    'territory',
  HOME:         'home',
  WATER_SOURCE: 'waterSource',
  CHANCE_SPOT:  'chanceSpot',
  DOG_PARK:     'dogPark',
  EVENTS:       'events',
  INTERSECTION: 'intersection',
  PATH:         'path',
  SIDE_STREET:  'sideStreet',
};

function defaultSpaceState() {
  return { owner: null, fortifyTokens: 0 };
}

class Board {
  constructor() {
    this.spaces = new Map();
    this.edges = new Map();
  }
  static fromJSON(json) {
    const b = new Board();
    for (const s of json.spaces) b.addSpace(s);
    for (const e of json.edges) b.addEdge(e.from, e.to, e.driveCost || 0);
    return b;
  }
  addSpace(def) {
    this.spaces.set(def.id, {
      id:           def.id,
      type:         def.type,
      label:        def.label        || def.id,
      facing:       def.facing       || null,
      playerColour: def.playerColour || null,
      pathExit:     def.pathExit     || null,
      ...defaultSpaceState(),
    });
  }
  addEdge(fromId, toId, driveCost = 0) {
    if (!this.edges.has(fromId)) this.edges.set(fromId, []);
    if (!this.edges.has(toId))   this.edges.set(toId, []);
    this.edges.get(fromId).push({ target: toId, driveCost });
    this.edges.get(toId).push({ target: fromId, driveCost });
  }
  getSpace(id)       { return this.spaces.get(id) || null; }
  getNeighbors(id)   { return (this.edges.get(id) || []).map(e => ({ space: this.spaces.get(e.target), driveCost: e.driveCost })); }
  getEdges(id)       { return this.edges.get(id) || []; }
  getSpacesByType(t) { const o = []; for (const s of this.spaces.values()) if (s.type === t) o.push(s); return o; }
  getTerritoriesOwnedBy(pid) { const o = []; for (const s of this.spaces.values()) if (s.type === SPACE_TYPES.TERRITORY && s.owner === pid) o.push(s); return o; }
  getAllSpaces()      { return [...this.spaces.values()]; }
  getHomeSpace(playerId, players) {
    const player = players.find(p => p.id === playerId);
    if (!player) return null;
    for (const s of this.spaces.values()) {
      if (s.type === SPACE_TYPES.HOME && s.playerColour === player.colour) return s;
    }
    return null;
  }
  getHomeNeighbourhood(playerId, players) {
    const home = this.getHomeSpace(playerId, players);
    if (!home) return [];
    return this.getNeighbors(home.id)
      .filter(n => n.space.type === SPACE_TYPES.TERRITORY)
      .map(n => n.space);
  }
  isHomeNeighbourhood(territoryId, playerId, players) {
    return this.getHomeNeighbourhood(playerId, players).some(s => s.id === territoryId);
  }
  areAllied(playerIdA, playerIdB, players) {
    const a = players.find(p => p.id === playerIdA);
    return a ? a.allies.includes(playerIdB) : false;
  }
  getMovementCost(fromId, toId) {
    const edges = this.edges.get(fromId);
    if (!edges) return null;
    const e = edges.find(e => e.target === toId);
    return e ? e.driveCost : null;
  }
  getConnectedTerritoryGroups(pid) {
    const owned = new Set();
    for (const s of this.spaces.values()) if (s.type === SPACE_TYPES.TERRITORY && s.owner === pid) owned.add(s.id);
    const visited = new Set(); const groups = [];
    for (const id of owned) {
      if (visited.has(id)) continue;
      const group = []; const stack = [id];
      while (stack.length > 0) {
        const cur = stack.pop();
        if (visited.has(cur)) continue;
        visited.add(cur); group.push(cur);
        for (const e of (this.edges.get(cur) || [])) if (owned.has(e.target) && !visited.has(e.target)) stack.push(e.target);
      }
      groups.push(group);
    }
    return groups;
  }
  isInCluster(tid, pid) {
    for (const g of this.getConnectedTerritoryGroups(pid)) if (g.includes(tid) && g.length >= 3) return true;
    return false;
  }
  resetState() { for (const s of this.spaces.values()) Object.assign(s, defaultSpaceState()); }
  toJSON() {
    const spaces = []; for (const s of this.spaces.values()) spaces.push({ ...s });
    const edges = []; const seen = new Set();
    for (const [fid, conns] of this.edges) for (const c of conns) {
      const key = [fid, c.target].sort().join('|');
      if (seen.has(key)) continue; seen.add(key);
      edges.push({ from: fid, to: c.target, driveCost: c.driveCost });
    }
    return { spaces, edges };
  }
}

// --- game.js ---

const DEFAULTS = {
  swaggerPerTerritories: 2,
  gritPenaltyThreshold:  5,
  maxFortify:            3,
  maxTurns:              30,
  territoryWinThreshold: 10,
  desperationThreshold:  3,
  desperationGritBonus:  2,
  houseboundTurns:       2,
};

function createPlayer(id, archetypeKey, homeSpaceId, colour) {
  const arch = ARCHETYPES[archetypeKey];
  if (!arch) throw new Error(`Unknown archetype: ${archetypeKey}`);
  return {
    id, colour, archetype: archetypeKey, position: homeSpaceId,
    water: arch.water, swagger: arch.swagger, drive: arch.drive, grit: arch.grit, bond: arch.bond,
    allies: [], zeroTerritoryTurns: 0, housebound: false,
  };
}

class Game {
  constructor(board, players, config = {}) {
    this.board = board; this.players = players;
    this.config = { ...DEFAULTS, ...config };
    this.turnNumber = 0; this.currentPlayerIndex = 0;
    this.gameOver = false; this.winner = null; this.log = [];
    this.pendingAlliances = new Map();
  }
  getPlayer(id)        { return this.players.find(p => p.id === id); }
  getCurrentPlayer()   { return this.players[this.currentPlayerIndex]; }
  getArchetype(player) { return ARCHETYPES[player.archetype]; }
  sortTurnOrder() {
    this.players.sort((a, b) =>
      this.board.getTerritoriesOwnedBy(a.id).length - this.board.getTerritoriesOwnedBy(b.id).length
    );
  }
  calculateSwaggerIncome(pid) {
    let total = 0;
    for (const g of this.board.getConnectedTerritoryGroups(pid)) total += Math.floor(g.length / this.config.swaggerPerTerritories);
    return total;
  }
  applyTerritoryIncome(pid) {
    const p = this.getPlayer(pid);
    const sw = this.calculateSwaggerIncome(pid);
    if (sw > 0) { p.swagger += sw; this._log(pid, `territory income: +${sw} swagger`); }
    const tc = this.board.getTerritoriesOwnedBy(pid).length;
    if (tc < this.config.desperationThreshold) {
      p.grit += this.config.desperationGritBonus;
      this._log(pid, `desperation: +${this.config.desperationGritBonus} grit`);
    }
  }

  // ── Validation ──
  canClaim(pid, tid) {
    const p = this.getPlayer(pid), s = this.board.getSpace(tid);
    if (!s || s.type !== SPACE_TYPES.TERRITORY) return { ok: false, reason: 'Not a territory' };
    if (s.owner !== null) return { ok: false, reason: 'Occupied' };
    if (p.water < 2) return { ok: false, reason: 'Need 2 water' };
    const ns = p.archetype !== 'bruiser';
    if (ns && p.swagger < 1) return { ok: false, reason: 'Need 1 swagger' };
    return { ok: true, waterCost: 2, swaggerCost: ns ? 1 : 0 };
  }
  canChallenge(pid, tid) {
    const p = this.getPlayer(pid), s = this.board.getSpace(tid);
    if (!s) return { ok: false, reason: 'Space not found' };
    if (s.type === SPACE_TYPES.HOME) return { ok: false, reason: 'Cannot challenge a home turf' };
    if (s.type !== SPACE_TYPES.TERRITORY) return { ok: false, reason: 'Not a territory' };
    if (s.owner === null) return { ok: false, reason: 'Empty — use Claim' };
    if (s.owner === pid) return { ok: false, reason: 'Own territory' };
    if (p.water < 2) return { ok: false, reason: 'Need 2 water' };
    if (p.drive < 1) return { ok: false, reason: 'Need 1 drive' };
    if (this.board.areAllied(pid, s.owner, this.players)) return { ok: false, reason: 'Alliance protection' };
    // Home neighbourhood transitive check
    if (this.board.isHomeNeighbourhood(tid, s.owner, this.players)) {
      const defender = this.getPlayer(s.owner);
      for (const allyId of defender.allies) {
        if (this.board.areAllied(pid, allyId, this.players))
          return { ok: false, reason: 'Alliance protection — home neighbourhood' };
      }
    }
    return { ok: true, waterCost: 2, driveCost: 1 };
  }
  canFortify(pid, tid) {
    const p = this.getPlayer(pid), s = this.board.getSpace(tid);
    if (!s || s.type !== SPACE_TYPES.TERRITORY) return { ok: false, reason: 'Not a territory' };
    if (s.owner !== pid) return { ok: false, reason: 'Not yours' };
    if (s.fortifyTokens >= this.config.maxFortify) return { ok: false, reason: 'Max fortify' };
    if (p.water < 1) return { ok: false, reason: 'Need 1 water' };
    const ng = p.archetype !== 'yapper';
    if (ng && p.grit < 1) return { ok: false, reason: 'Need 1 grit' };
    return { ok: true, waterCost: 1, gritCost: ng ? 1 : 0 };
  }
  canAlly(pid, dogParkSpaceId) {
    const p = this.getPlayer(pid), s = this.board.getSpace(dogParkSpaceId);
    if (!s || s.type !== SPACE_TYPES.DOG_PARK) return { ok: false, reason: 'Not a dog park' };
    if (p.water < 1) return { ok: false, reason: 'Need 1 water' };
    const nb = p.archetype !== 'diplomat';
    if (nb && p.bond < 1) return { ok: false, reason: 'Need 1 bond' };
    return { ok: true, waterCost: 1, bondCost: nb ? 1 : 0 };
  }
  canBreakAlliance(pid, alliedPlayerId) {
    const p = this.getPlayer(pid);
    if (!p.allies.includes(alliedPlayerId)) return { ok: false, reason: 'Not allied' };
    if (p.water < 1) return { ok: false, reason: 'Need 1 water' };
    if (p.swagger < 1) return { ok: false, reason: 'Need 1 swagger' };
    return { ok: true, waterCost: 1, swaggerCost: 1 };
  }
  canDrink(pid) {
    const p = this.getPlayer(pid);
    const nd = p.archetype !== 'scrapper';
    if (nd && p.drive < 1) return { ok: false, reason: 'Need 1 drive' };
    return { ok: true, driveCost: nd ? 1 : 0 };
  }
  canReClaim(pid) {
    const p = this.getPlayer(pid);
    if (p.swagger >= 1) return { ok: true, resource: 'swagger' };
    if (p.grit >= 1)    return { ok: true, resource: 'grit' };
    return { ok: false, reason: 'Need 1 swagger or 1 grit' };
  }

  // ── Actions ──
  claim(pid, tid) {
    const c = this.canClaim(pid, tid); if (!c.ok) return { success: false, reason: c.reason };
    const p = this.getPlayer(pid), s = this.board.getSpace(tid);
    p.water -= c.waterCost; p.swagger -= c.swaggerCost; s.owner = pid;
    this._log(pid, `claimed ${tid}`); return { success: true };
  }
  payChallengeCost(pid, tid) {
    const c = this.canChallenge(pid, tid); if (!c.ok) return { success: false, reason: c.reason };
    const p = this.getPlayer(pid);
    p.water -= c.waterCost; p.drive -= c.driveCost;
    this._log(pid, `paid challenge cost for ${tid}`);
    return { success: true, defenderId: this.board.getSpace(tid).owner };
  }
  resolveChallenge(attackerId, defenderId, tid, attackRoll, defendRoll) {
    const att = this.getPlayer(attackerId), def = this.getPlayer(defenderId), space = this.board.getSpace(tid);
    let aT = attackRoll, dT = defendRoll;
    dT += space.fortifyTokens;
    if (att.archetype === 'diplomat') aT -= 1;
    if (att.grit > this.config.gritPenaltyThreshold) aT -= (att.grit - this.config.gritPenaltyThreshold);
    const yapperGrit = def.archetype === 'yapper';
    if (yapperGrit) { att.grit += 1; this._log(attackerId, '+1 grit (challenged yapper)'); }
    const cluster = this.board.isInCluster(tid, defenderId);
    let outcome;
    if (aT > dT) outcome = 'attackerWins';
    else if (aT === dT) outcome = cluster ? 'defenderWins' : 'tie';
    else outcome = 'defenderWins';
    const result = { outcome, attackRoll, defendRoll, attackTotal: aT, defendTotal: dT, fortifyBonus: space.fortifyTokens, clusterRule: cluster, yapperGrit };
    if (outcome === 'attackerWins') {
      space.owner = null; space.fortifyTokens = 0;
      result.canReClaim = this.canReClaim(attackerId);
      this._log(attackerId, `won challenge at ${tid} (${aT} vs ${dT})`);
    } else if (outcome === 'defenderWins') {
      att.grit += 1;
      this._log(attackerId, `lost challenge at ${tid} (+1 grit)`);
    }
    return result;
  }
  reClaim(pid, tid, useResource) {
    const p = this.getPlayer(pid), s = this.board.getSpace(tid);
    if (useResource === 'swagger') { if (p.swagger < 1) return { success: false }; p.swagger -= 1; }
    else if (useResource === 'grit') { if (p.grit < 1) return { success: false }; p.grit -= 1; }
    else return { success: false };
    s.owner = pid;
    this._log(pid, `re-claimed ${tid} with ${useResource}`); return { success: true };
  }
  declineReClaim(tid) { this._log(null, `re-claim declined at ${tid}`); return { success: true }; }
  fortify(pid, tid) {
    const c = this.canFortify(pid, tid); if (!c.ok) return { success: false, reason: c.reason };
    const p = this.getPlayer(pid), s = this.board.getSpace(tid);
    p.water -= c.waterCost; p.grit -= c.gritCost; s.fortifyTokens += 1;
    this._log(pid, `fortified ${tid} (${s.fortifyTokens}/${this.config.maxFortify})`); return { success: true };
  }

  // ── Alliance ──
  ally(pid, dogParkSpaceId) {
    const c = this.canAlly(pid, dogParkSpaceId); if (!c.ok) return { success: false, reason: c.reason };
    const p = this.getPlayer(pid);
    p.water -= c.waterCost; p.bond -= c.bondCost;
    this.pendingAlliances.set(dogParkSpaceId, pid);
    this._log(pid, `initiated alliance at ${dogParkSpaceId}`); return { success: true };
  }
  compulsoryBondJoin(pid, dogParkSpaceId) {
    const p = this.getPlayer(pid);
    if (!this.pendingAlliances.has(dogParkSpaceId)) return { success: false, reason: 'No pending alliance' };
    const initiatorId = this.pendingAlliances.get(dogParkSpaceId);
    if (initiatorId === pid) return { success: false, reason: 'Cannot join own alliance' };
    if (p.allies.includes(initiatorId)) return { success: false, reason: 'Already allied' };
    if (p.water < 1) return { success: false, reason: 'No water' };
    const initiator = this.getPlayer(initiatorId);
    p.water -= 1;
    if (!p.allies.includes(initiatorId)) p.allies.push(initiatorId);
    if (!initiator.allies.includes(pid)) initiator.allies.push(pid);
    this.pendingAlliances.delete(dogParkSpaceId);
    this._log(pid, `joined alliance with ${initiatorId} at ${dogParkSpaceId}`);
    // Friendship sacrifice: clear claims in each other's home neighbourhood
    const cleared = [];
    const joinerHood = this.board.getHomeNeighbourhood(pid, this.players);
    for (const t of joinerHood) {
      if (t.owner === initiatorId) {
        t.owner = null; t.fortifyTokens = 0; cleared.push(t.id);
        this._log(initiatorId, `claim cleared at ${t.id} (friendship sacrifice)`);
      }
    }
    const initiatorHood = this.board.getHomeNeighbourhood(initiatorId, this.players);
    for (const t of initiatorHood) {
      if (t.owner === pid) {
        t.owner = null; t.fortifyTokens = 0; cleared.push(t.id);
        this._log(pid, `claim cleared at ${t.id} (friendship sacrifice)`);
      }
    }
    return { success: true, cleared };
  }
  breakAlliance(pid, alliedPlayerId) {
    const c = this.canBreakAlliance(pid, alliedPlayerId); if (!c.ok) return { success: false, reason: c.reason };
    const p = this.getPlayer(pid), ally = this.getPlayer(alliedPlayerId);
    p.water -= c.waterCost; p.swagger -= c.swaggerCost;
    p.allies = p.allies.filter(id => id !== alliedPlayerId);
    ally.allies = ally.allies.filter(id => id !== pid);
    this._log(pid, `broke alliance with ${alliedPlayerId}`); return { success: true };
  }

  // ── Shortcut ──
  takeShortcut(pid, pathEntryId) {
    const p = this.getPlayer(pid), s = this.board.getSpace(pathEntryId);
    if (!s || s.type !== SPACE_TYPES.PATH) return { success: false, reason: 'Not a path space' };
    if (p.position !== pathEntryId) return { success: false, reason: 'Not at path entry' };
    if (!s.pathExit) return { success: false, reason: 'No exit' };
    if (p.drive < 1) return { success: false, reason: 'Need 1 drive' };
    p.drive -= 1; p.position = s.pathExit;
    this._log(pid, `took shortcut ${pathEntryId} → ${s.pathExit}`);
    return { success: true, exitSpaceId: s.pathExit };
  }

  // ── Drink ──
  drink(pid, waterGain) {
    const c = this.canDrink(pid); if (!c.ok) return { success: false, reason: c.reason };
    const p = this.getPlayer(pid), arch = this.getArchetype(p);
    p.drive -= c.driveCost; p.water = Math.min(p.water + waterGain, arch.water);
    this._log(pid, `drank: +${waterGain} water (now ${p.water}/${arch.water})`); return { success: true };
  }

  // ── Movement ──
  getPassThroughEffects(spaceId, pid) {
    const s = this.board.getSpace(spaceId); if (!s) return [];
    const effects = [];
    switch (s.type) {
      case SPACE_TYPES.CHANCE_SPOT: effects.push({ type: 'chanceCard' }); break;
      case SPACE_TYPES.DOG_PARK:
        if (this.pendingAlliances.has(spaceId)) {
          const initId = this.pendingAlliances.get(spaceId);
          const player = this.getPlayer(pid);
          if (initId !== pid && player && !player.allies.includes(initId)) {
            effects.push({ type: 'compulsoryBond', dogParkSpaceId: spaceId }); break;
          }
        }
        effects.push({ type: 'dogPark' }); break;
      case SPACE_TYPES.EVENTS: effects.push({ type: 'eventsCard' }); break;
      case SPACE_TYPES.HOME: {
        const player = this.getPlayer(pid);
        if (player && s.playerColour === player.colour) effects.push({ type: 'homeResupply' });
        break;
      }
      case SPACE_TYPES.PATH:
        if (s.pathExit) effects.push({ type: 'pathEntry', exitSpaceId: s.pathExit });
        break;
    }
    return effects;
  }
  movePlayer(pid, path) {
    const p = this.getPlayer(pid);
    if (path.length === 0) return { success: true, driveCost: 0, effects: [] };
    if (path[0] !== p.position) return { success: false, reason: 'Path must start at current position' };
    let totalDrive = 0;
    for (let i = 1; i < path.length; i++) {
      const cost = this.board.getMovementCost(path[i-1], path[i]);
      if (cost === null) return { success: false, reason: `No connection: ${path[i-1]} -> ${path[i]}` };
      totalDrive += cost;
    }
    if (p.drive < totalDrive) return { success: false, reason: `Not enough drive (need ${totalDrive})` };
    const effects = [];
    for (let i = 1; i < path.length; i++) {
      for (const eff of this.getPassThroughEffects(path[i], pid)) effects.push({ ...eff, spaceId: path[i] });
    }
    p.drive -= totalDrive; p.position = path[path.length - 1];
    this._log(pid, `moved to ${p.position} (${totalDrive} drive)`);
    return { success: true, driveCost: totalDrive, effects };
  }
  applyDogPark(pid) { this.getPlayer(pid).bond += 1; this._log(pid, '+1 bond (dog park)'); }
  applyHomeResupply(pid) {
    const p = this.getPlayer(pid), arch = this.getArchetype(p);
    p.water = arch.water;
    p.swagger = Math.max(p.swagger, arch.swagger);
    p.drive   = Math.max(p.drive, arch.drive);
    p.grit    = Math.max(p.grit, arch.grit);
    p.bond    = Math.max(p.bond, arch.bond);
    this._log(pid, 'home resupply');
  }

  // ── Win conditions ──
  checkWinConditions() {
    for (const p of this.players) {
      const c = this.board.getTerritoriesOwnedBy(p.id).length;
      if (c >= this.config.territoryWinThreshold) {
        this.gameOver = true; this.winner = p.id;
        this._log(p.id, `wins — ${c} territories!`);
        return { gameOver: true, winner: p.id, reason: 'territory threshold' };
      }
    }
    if (this.turnNumber > 2) {
      const wt = this.players.filter(p => this.board.getTerritoriesOwnedBy(p.id).length > 0);
      if (wt.length === 1) {
        this.gameOver = true; this.winner = wt[0].id;
        return { gameOver: true, winner: wt[0].id, reason: 'last standing' };
      }
    }
    if (this.turnNumber >= this.config.maxTurns) {
      const ranked = [...this.players].sort((a, b) => {
        const aT = this.board.getTerritoriesOwnedBy(a.id), bT = this.board.getTerritoriesOwnedBy(b.id);
        if (bT.length !== aT.length) return bT.length - aT.length;
        const aF = aT.reduce((s,t) => s+t.fortifyTokens,0), bF = bT.reduce((s,t) => s+t.fortifyTokens,0);
        if (bF !== aF) return bF - aF;
        return b.swagger - a.swagger;
      });
      this.gameOver = true; this.winner = ranked[0].id;
      return { gameOver: true, winner: ranked[0].id, reason: 'turn limit', rankings: ranked.map(p => p.id) };
    }
    return { gameOver: false };
  }

  // ── Maintenance ──
  checkHousebound(pid) {
    const p = this.getPlayer(pid);
    if (this.board.getTerritoriesOwnedBy(pid).length === 0) {
      p.zeroTerritoryTurns += 1;
      if (p.zeroTerritoryTurns >= this.config.houseboundTurns) { p.housebound = true; this._log(pid, 'is housebound'); }
    } else { p.zeroTerritoryTurns = 0; p.housebound = false; }
  }

  // ── Turn management ──
  startRound() {
    this.turnNumber += 1; this.sortTurnOrder(); this.currentPlayerIndex = 0;
    this._log(null, `=== Round ${this.turnNumber} ===`);
  }
  advancePlayer() { this.currentPlayerIndex += 1; return this.currentPlayerIndex < this.players.length; }

  static rollD6(rng) { if (rng) return rng(1, 6); return Math.floor(Math.random() * 6) + 1; }
  static roll2D6(rng) { return Game.rollD6(rng) + Game.rollD6(rng); }
  rollMovement(pid, rng) {
    const p = this.getPlayer(pid);
    let roll = Game.roll2D6(rng);
    if (p.housebound) roll = Math.floor(roll / 2);
    return roll;
  }
  getState() {
    return {
      turnNumber: this.turnNumber, currentPlayerIndex: this.currentPlayerIndex,
      gameOver: this.gameOver, winner: this.winner,
      players: this.players.map(p => ({ ...p, allies: [...p.allies] })),
      board: this.board.toJSON(),
      pendingAlliances: Object.fromEntries(this.pendingAlliances),
      log: [...this.log],
    };
  }
  _log(pid, msg) { this.log.push({ turn: this.turnNumber, player: pid, message: msg }); }
}

// ═══════════════════════════════════════════════════════════════════════
//  CONSTANTS & GLOBALS
// ═══════════════════════════════════════════════════════════════════════

const COLOUR_HEX = { blue: '#5080e0', purple: '#9060c0', orange: '#e0a050', yellow: '#e0d050' };
const COLOUR_ORDER = ['blue', 'purple', 'orange', 'yellow'];
const SVG_NS = 'http://www.w3.org/2000/svg';
const CELL = 64;

// ── Stamp footprints (inlined from board-builder) ──

const COMPOUND_FP = [
  // rot 0  N — yard on top
  [{dr:0,dc:0,sub:'yard'},{dr:0,dc:1,sub:'yard'},
   {dr:1,dc:0,sub:'house'},{dr:1,dc:1,sub:'house'},
   {dr:2,dc:0,sub:'house'},{dr:2,dc:1,sub:'house'}],
  // rot 1  E — yard on right
  [{dr:0,dc:0,sub:'house'},{dr:0,dc:1,sub:'house'},{dr:0,dc:2,sub:'yard'},
   {dr:1,dc:0,sub:'house'},{dr:1,dc:1,sub:'house'},{dr:1,dc:2,sub:'yard'}],
  // rot 2  S — yard on bottom
  [{dr:0,dc:0,sub:'house'},{dr:0,dc:1,sub:'house'},
   {dr:1,dc:0,sub:'house'},{dr:1,dc:1,sub:'house'},
   {dr:2,dc:0,sub:'yard'},{dr:2,dc:1,sub:'yard'}],
  // rot 3  W — yard on left
  [{dr:0,dc:0,sub:'yard'},{dr:0,dc:1,sub:'house'},{dr:0,dc:2,sub:'house'},
   {dr:1,dc:0,sub:'yard'},{dr:1,dc:1,sub:'house'},{dr:1,dc:2,sub:'house'}],
];

const STAMP_FP = {
  sidewalk: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:1,dc:0,sub:'main'}],
    ],
    colors: {main:'#d4b896'},
  },
  road: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:1,dc:0,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'}],
    ],
    colors: {main:'#888888'},
  },
  intersection: {
    fp: [[{dr:0,dc:0,sub:'main'}]],
    colors: {main:'#aaaaaa'},
  },
  territory: {
    fp: COMPOUND_FP,
    colors: {yard:'#7ec850', house:'#c87850'},
  },
  home: {
    fp: COMPOUND_FP,
    colors: {yard:'#88aaff', house:'#4477dd'},
  },
  dogPark: {
    fp: [[{dr:0,dc:0,sub:'main'}]],
    colors: {main:'#40c080'},
  },
  waterPark: {
    fp: [[{dr:0,dc:0,sub:'main'}]],
    colors: {main:'#40a8a0'},
  },
  pathStraight: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:1,dc:0,sub:'main'}],
    ],
    colors: {main:'#c8a878'},
  },
  pathCorner: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:1,dc:1,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:1,dc:1,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:1,dc:1,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:1,dc:1,sub:'main'}],
    ],
    colors: {main:'#c8a878'},
  },
  sidewalk3: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:0,dc:2,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:2,dc:0,sub:'main'}],
    ],
    colors: {main:'#d4b896'},
  },
  road3: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:2,dc:0,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:0,dc:2,sub:'main'}],
    ],
    colors: {main:'#888888'},
  },
  pathStraight3: {
    fp: [
      [{dr:0,dc:0,sub:'main'},{dr:0,dc:1,sub:'main'},{dr:0,dc:2,sub:'main'}],
      [{dr:0,dc:0,sub:'main'},{dr:1,dc:0,sub:'main'},{dr:2,dc:0,sub:'main'}],
    ],
    colors: {main:'#c8a878'},
  },
};

const HOME_PLAYER_COLORS = {
  blue:   {yard:'#88aaff', house:'#4477dd'},
  purple: {yard:'#cc88ff', house:'#8844cc'},
  orange: {yard:'#ffbb66', house:'#dd8833'},
  yellow: {yard:'#ffee66', house:'#ccbb33'},
};

function getStampCells(type, rot) {
  const s = STAMP_FP[type];
  if (!s) return [];
  return s.fp[rot % s.fp.length];
}

function getCellColor(type, sub, playerColour) {
  if (type === 'home' && playerColour && HOME_PLAYER_COLORS[playerColour])
    return HOME_PLAYER_COLORS[playerColour][sub] || '#888';
  return STAMP_FP[type]?.colors[sub] || '#555';
}

let boardData = null;       // raw JSON
let board = null;           // Board instance
let game = null;            // Game instance
let playerConfigs = [];     // { id, name, archetype, isAI, homeSpaceId, colour }
let positions = {};         // spaceId → { x, y } in SVG coords (first cell center)
let cellToSpaceId = {};     // "row,col" → spaceId
let spaceIdToCells = {};    // spaceId → [{row,col}, ...]
let gridRows = 0, gridCols = 0;
let svgEl = null;
let layerCells, layerOverlay, layerHighlight, layerPawns;

// Interaction promises
let _resolveSpaceClick = null;
let _validSpaceIds = null;
let _resolveControlBtn = null;

// ═══════════════════════════════════════════════════════════════════════
//  SETUP SCREEN
// ═══════════════════════════════════════════════════════════════════════

function initSetup() {
  document.getElementById('board-file').addEventListener('change', onBoardFileChange);

  // Player count buttons
  const countBtns = document.getElementById('count-btns');
  for (let n = 2; n <= 4; n++) {
    const btn = document.createElement('button');
    btn.textContent = n;
    btn.dataset.count = n;
    if (n === 2) btn.classList.add('active');
    btn.addEventListener('click', () => {
      countBtns.querySelectorAll('button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      buildPlayerConfigRows(n);
    });
    countBtns.appendChild(btn);
  }

  document.getElementById('btn-start').addEventListener('click', onStartGame);
}

function onBoardFileChange(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      boardData = JSON.parse(ev.target.result);
      const homeCount = boardData.spaces.filter(s => s.type === SPACE_TYPES.HOME).length;
      const info = document.getElementById('board-info');
      info.textContent = `${boardData.spaces.length} spaces, ${boardData.edges.length} edges, ${homeCount} homes`;
      info.className = '';
      document.getElementById('player-setup').style.display = '';

      // Limit player count to available homes
      const maxPlayers = Math.min(4, homeCount);
      const countBtns = document.getElementById('count-btns');
      countBtns.querySelectorAll('button').forEach(b => {
        const n = parseInt(b.dataset.count);
        b.disabled = n > maxPlayers;
        b.classList.remove('active');
      });
      // Select first valid count
      const firstValid = countBtns.querySelector(`button:not(:disabled)`);
      if (firstValid) { firstValid.classList.add('active'); buildPlayerConfigRows(parseInt(firstValid.dataset.count)); }

      document.getElementById('btn-start').disabled = homeCount < 2;
    } catch (err) {
      const info = document.getElementById('board-info');
      info.textContent = 'Error: ' + err.message;
      info.className = 'error';
    }
  };
  reader.readAsText(file);
}

function buildPlayerConfigRows(count) {
  const container = document.getElementById('player-configs');
  container.innerHTML = '';
  const archetypeKeys = Object.keys(ARCHETYPES);
  for (let i = 0; i < count; i++) {
    const colour = COLOUR_HEX[COLOUR_ORDER[i]] || '#888';
    const row = document.createElement('div');
    row.className = 'player-row';
    row.innerHTML = `
      <span class="player-dot" style="background:${colour}"></span>
      <input type="text" value="Player ${i+1}" data-field="name" />
      <select data-field="archetype">
        ${archetypeKeys.map((k, j) => `<option value="${k}" ${j === i % archetypeKeys.length ? 'selected' : ''}>${ARCHETYPES[k].name}</option>`).join('')}
      </select>
      <select data-field="control">
        <option value="human" ${i === 0 ? 'selected' : ''}>Human</option>
        <option value="ai" ${i > 0 ? 'selected' : ''}>AI</option>
      </select>
    `;
    container.appendChild(row);
  }
}

function onStartGame() {
  if (!boardData) return;
  const rows = document.querySelectorAll('#player-configs .player-row');
  const homes = boardData.spaces.filter(s => s.type === SPACE_TYPES.HOME);

  playerConfigs = [];
  board = Board.fromJSON(boardData);

  for (let i = 0; i < rows.length; i++) {
    const name = rows[i].querySelector('[data-field="name"]').value.trim() || `Player ${i+1}`;
    const archetype = rows[i].querySelector('[data-field="archetype"]').value;
    const isAI = rows[i].querySelector('[data-field="control"]').value === 'ai';
    const homeId = homes[i].id;
    const id = `p${i+1}`;
    // Read colour from the home space's playerColour field
    const homeSpace = board.getSpace(homeId);
    const colour = (homeSpace && homeSpace.playerColour) || COLOUR_ORDER[i];
    playerConfigs.push({ id, name, archetype, isAI, homeSpaceId: homeId, colour });
  }

  // Build position map from _positions
  buildPositionMap();

  // Create players (v1.3.0: pass colour)
  const players = playerConfigs.map(c => createPlayer(c.id, c.archetype, c.homeSpaceId, c.colour));
  game = new Game(board, players);

  // Switch to game screen
  document.getElementById('setup-screen').style.display = 'none';
  document.getElementById('game-screen').classList.add('visible');

  // Build SVG
  buildBoardSVG();
  updateOverlay();
  updatePawns();
  updateSidebar();

  // Start the game loop
  runGame();
}

// ═══════════════════════════════════════════════════════════════════════
//  POSITION MAP
// ═══════════════════════════════════════════════════════════════════════

function buildPositionMap() {
  positions = {};
  cellToSpaceId = {};
  spaceIdToCells = {};
  gridRows = 0;
  gridCols = 0;

  if (boardData._grid) {
    gridRows = boardData._grid.rows || 0;
    gridCols = boardData._grid.cols || 0;
  }

  if (boardData._positions && boardData._positions.length > 0) {
    for (const p of boardData._positions) {
      const key = `${p.row},${p.col}`;
      cellToSpaceId[key] = p.id;
      if (!spaceIdToCells[p.id]) spaceIdToCells[p.id] = [];
      spaceIdToCells[p.id].push({ row: p.row, col: p.col });
      // First occurrence becomes the pawn position
      if (!positions[p.id]) {
        positions[p.id] = { x: p.col * CELL + CELL / 2, y: p.row * CELL + CELL / 2 };
      }
    }
  } else {
    // Fallback: arrange in a grid
    const count = boardData.spaces.length;
    const cols = Math.ceil(Math.sqrt(count * 1.5));
    gridCols = cols;
    gridRows = Math.ceil(count / cols);
    boardData.spaces.forEach((s, i) => {
      const col = i % cols;
      const row = Math.floor(i / cols);
      positions[s.id] = { x: col * CELL + CELL / 2, y: row * CELL + CELL / 2 };
      const key = `${row},${col}`;
      cellToSpaceId[key] = s.id;
      spaceIdToCells[s.id] = [{ row, col }];
    });
  }
}

// ═══════════════════════════════════════════════════════════════════════
//  SVG RENDERER
// ═══════════════════════════════════════════════════════════════════════

function buildBoardSVG() {
  svgEl = document.getElementById('board-svg');
  svgEl.innerHTML = '';

  // ViewBox from grid dimensions
  const vw = gridCols * CELL;
  const vh = gridRows * CELL;
  svgEl.setAttribute('viewBox', `0 0 ${vw} ${vh}`);
  svgEl.setAttribute('width', vw);
  svgEl.setAttribute('height', vh);

  // Background
  const bg = svgCreate('rect', { x: 0, y: 0, width: vw, height: vh, fill: '#2a2a3e' });
  svgEl.appendChild(bg);

  // Layers
  layerCells     = svgG('cells-layer');
  layerOverlay   = svgG('overlay-layer');
  layerHighlight = svgG('highlight-layer');
  layerPawns     = svgG('pawns-layer');
  svgEl.append(layerCells, layerOverlay, layerHighlight, layerPawns);

  // Paint grid components
  if (boardData._grid && boardData._grid.components) {
    for (const comp of boardData._grid.components) {
      const cells = getStampCells(comp.type, comp.rotation);
      for (const cell of cells) {
        const absRow = comp.row + cell.dr;
        const absCol = comp.col + cell.dc;
        const x = absCol * CELL;
        const y = absRow * CELL;
        const fill = getCellColor(comp.type, cell.sub, comp.playerColour);
        const key = `${absRow},${absCol}`;
        const spaceId = cellToSpaceId[key] || null;

        const rect = svgCreate('rect', {
          x, y, width: CELL, height: CELL,
          fill,
          class: 'cell-rect' + (spaceId ? ' cell-interactive' : ''),
        });
        if (spaceId) rect.dataset.spaceId = spaceId;
        layerCells.appendChild(rect);
      }
    }
  }

  // Click handler (event delegation)
  svgEl.addEventListener('click', (e) => {
    const el = e.target.closest('[data-space-id]');
    if (!el) return;
    const sid = el.dataset.spaceId;
    if (_resolveSpaceClick && _validSpaceIds && _validSpaceIds.includes(sid)) {
      _resolveSpaceClick(sid);
      _resolveSpaceClick = null;
      _validSpaceIds = null;
    }
  });
}

function updateOverlay() {
  layerOverlay.innerHTML = '';
  for (const s of board.getAllSpaces()) {
    const cells = spaceIdToCells[s.id];
    if (!cells || cells.length === 0) continue;

    // Ownership border — draw on each cell
    if (s.owner) {
      const cfg = playerConfigs.find(c => c.id === s.owner);
      if (cfg) {
        const colour = COLOUR_HEX[cfg.colour] || cfg.colour;
        for (const cell of cells) {
          const ownerRect = svgCreate('rect', {
            x: cell.col * CELL + 1, y: cell.row * CELL + 1,
            width: CELL - 2, height: CELL - 2,
            stroke: colour, class: 'owner-border',
          });
          layerOverlay.appendChild(ownerRect);
        }
      }
    }

    // Fortify tokens (small white dots on first cell)
    if (s.fortifyTokens > 0) {
      const fc = cells[0];
      const cx = fc.col * CELL + CELL / 2;
      const cy = fc.row * CELL + CELL - 10;
      for (let f = 0; f < s.fortifyTokens; f++) {
        const fx = cx - 10 + f * 10;
        const dot = svgCreate('circle', { cx: fx, cy, r: 3.5, class: 'fortify-dot' });
        layerOverlay.appendChild(dot);
      }
    }

    // Pending alliance marker at dog parks
    if (game && s.type === SPACE_TYPES.DOG_PARK && game.pendingAlliances.has(s.id)) {
      const initId = game.pendingAlliances.get(s.id);
      const initCfg = playerConfigs.find(c => c.id === initId);
      const fc = cells[0];
      const heart = svgCreate('text', {
        x: fc.col * CELL + CELL / 2, y: fc.row * CELL + 14,
        'text-anchor': 'middle', 'dominant-baseline': 'middle',
        fill: initCfg ? (COLOUR_HEX[initCfg.colour] || initCfg.colour) : '#e05080',
        'font-size': '14px',
      });
      heart.textContent = '\u2665';
      layerOverlay.appendChild(heart);
    }
  }
}

function updatePawns() {
  layerPawns.innerHTML = '';
  // Group players by position
  const byPos = {};
  for (const p of game.players) {
    if (!byPos[p.position]) byPos[p.position] = [];
    byPos[p.position].push(p);
  }
  const offsets = {
    1: [[0, 0]],
    2: [[-8, 0], [8, 0]],
    3: [[-8, -6], [8, -6], [0, 8]],
    4: [[-8, -6], [8, -6], [-8, 8], [8, 8]],
  };
  for (const [posId, players] of Object.entries(byPos)) {
    const pos = positions[posId];
    if (!pos) continue;
    const offs = offsets[players.length] || offsets[4];
    for (let i = 0; i < players.length; i++) {
      const cfg = playerConfigs.find(c => c.id === players[i].id);
      const ox = offs[i] ? offs[i][0] : 0;
      const oy = offs[i] ? offs[i][1] : 0;
      const pawn = svgCreate('circle', {
        cx: pos.x + ox, cy: pos.y + oy, r: 7,
        fill: cfg ? (COLOUR_HEX[cfg.colour] || cfg.colour) : '#fff',
        class: 'pawn',
      });
      layerPawns.appendChild(pawn);
    }
  }
}

function highlightSpaces(ids, cls = 'highlight') {
  layerHighlight.innerHTML = '';
  for (const id of ids) {
    const cells = spaceIdToCells[id];
    if (!cells) continue;
    for (const cell of cells) {
      const r = svgCreate('rect', {
        x: cell.col * CELL, y: cell.row * CELL,
        width: CELL, height: CELL,
        class: cls,
      });
      layerHighlight.appendChild(r);
    }
  }
}
function clearHighlights() { layerHighlight.innerHTML = ''; }

// SVG helpers
function svgCreate(tag, attrs = {}) {
  const el = document.createElementNS(SVG_NS, tag);
  for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);
  return el;
}
function svgG(id) {
  const g = document.createElementNS(SVG_NS, 'g');
  if (id) g.id = id;
  return g;
}

// ═══════════════════════════════════════════════════════════════════════
//  UI HELPERS
// ═══════════════════════════════════════════════════════════════════════

function updateSidebar() {
  if (!game) return;
  const cp = game.getCurrentPlayer();
  const cfg = playerConfigs.find(c => c.id === cp.id);
  const colHex = COLOUR_HEX[cfg.colour] || cfg.colour;

  // Turn info
  document.getElementById('turn-info').innerHTML = `
    <div class="stat-row"><span class="label">Round</span><span class="value">${game.turnNumber}</span></div>
    <div class="stat-row"><span class="label">Max turns</span><span class="value">${game.config.maxTurns}</span></div>
  `;

  // Allies list
  let alliesHtml = '';
  if (cp.allies.length > 0) {
    const allyNames = cp.allies.map(aid => {
      const ac = playerConfigs.find(c => c.id === aid);
      return ac ? ac.name : aid;
    }).join(', ');
    alliesHtml = `<div class="stat-row"><span class="label">Allies</span><span class="value" style="color:#e05080">${allyNames}</span></div>`;
  }

  // Current player stats
  document.getElementById('current-player-stats').innerHTML = `
    <div class="stat-row" style="color:${colHex};font-weight:bold;font-size:14px">${cfg.name} (${ARCHETYPES[cfg.archetype].name})</div>
    <div class="stat-row stat-water"><span class="label">Water</span><span class="value">${cp.water} / ${ARCHETYPES[cp.archetype].water}</span></div>
    <div class="stat-row stat-swagger"><span class="label">Swagger</span><span class="value">${cp.swagger}</span></div>
    <div class="stat-row stat-drive"><span class="label">Drive</span><span class="value">${cp.drive}</span></div>
    <div class="stat-row stat-grit"><span class="label">Grit</span><span class="value">${cp.grit}</span></div>
    <div class="stat-row stat-bond"><span class="label">Bond</span><span class="value">${cp.bond}</span></div>
    ${alliesHtml}
    <div class="stat-row"><span class="label">Position</span><span class="value">${cp.position}</span></div>
    ${cp.housebound ? '<div class="stat-row" style="color:#c44">HOUSEBOUND</div>' : ''}
  `;

  // All players summary
  let html = '';
  for (const p of game.players) {
    const c = playerConfigs.find(c => c.id === p.id);
    const cHex = COLOUR_HEX[c.colour] || c.colour;
    const terr = board.getTerritoriesOwnedBy(p.id).length;
    const isCurrent = p.id === cp.id ? ' current' : '';
    const allyDots = p.allies.length > 0 ? ` \u2665${p.allies.length}` : '';
    html += `<div class="player-summary${isCurrent}">
      <span class="ps-dot" style="background:${cHex}"></span>
      <span class="ps-name">${c.name}</span>
      <span class="ps-terr">${terr} T${allyDots}</span>
    </div>`;
  }
  document.getElementById('all-players-summary').innerHTML = html;
}

function setPhase(text) {
  document.getElementById('phase-banner').textContent = text;
}

function addLogEntry(text, cls = '') {
  const div = document.createElement('div');
  div.className = 'log-entry' + (cls ? ' ' + cls : '');
  div.textContent = text;
  const log = document.getElementById('game-log');
  log.appendChild(div);
  log.scrollTop = log.scrollHeight;
}

function showDice(d1, d2, total) {
  const dd = document.getElementById('dice-display');
  document.getElementById('die1').textContent = d1;
  document.getElementById('die2').textContent = d2;
  document.getElementById('die-total').textContent = total !== null ? total : '';
  dd.classList.add('visible');
}
function hideDice() {
  document.getElementById('dice-display').classList.remove('visible');
}

// Controls bar — dynamic buttons
function setControls(items) {
  const bar = document.getElementById('controls-bar');
  bar.innerHTML = '';
  for (const item of items) {
    if (item.type === 'info') {
      const span = document.createElement('span');
      span.className = 'ctrl-info';
      span.textContent = item.text;
      bar.appendChild(span);
    } else if (item.type === 'spacer') {
      const span = document.createElement('span');
      span.className = 'ctrl-spacer';
      bar.appendChild(span);
    } else if (item.type === 'button') {
      const btn = document.createElement('button');
      btn.className = 'ctrl-btn' + (item.cls ? ' ' + item.cls : '');
      btn.textContent = item.text;
      btn.addEventListener('click', () => {
        if (_resolveControlBtn) { _resolveControlBtn(item.value); _resolveControlBtn = null; }
      });
      bar.appendChild(btn);
    }
  }
}
function clearControls() { document.getElementById('controls-bar').innerHTML = ''; }

// ═══════════════════════════════════════════════════════════════════════
//  INTERACTION PROMISES
// ═══════════════════════════════════════════════════════════════════════

function waitForSpaceClick(validIds) {
  return new Promise((resolve) => {
    _validSpaceIds = validIds;
    _resolveSpaceClick = resolve;
  });
}

function waitForControl() {
  return new Promise((resolve) => { _resolveControlBtn = resolve; });
}

function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

// ═══════════════════════════════════════════════════════════════════════
//  ACTION HELPERS
// ═══════════════════════════════════════════════════════════════════════

function getActionableSpaces(player) {
  const result = [];
  const currentId = player.position;
  const neighbors = board.getNeighbors(currentId);
  const allTargets = [currentId, ...neighbors.map(n => n.space.id)];
  const seen = new Set();

  for (const tid of allTargets) {
    if (seen.has(tid)) continue; seen.add(tid);
    const s = board.getSpace(tid);
    if (!s) continue;
    const actions = [];

    if (s.type === SPACE_TYPES.TERRITORY) {
      if (s.owner === null && game.canClaim(player.id, tid).ok)
        actions.push({ type: 'claim', targetId: tid, label: `Claim ${s.label}`, cost: 'W:2 Sw:1' });
      if (s.owner && s.owner !== player.id && game.canChallenge(player.id, tid).ok)
        actions.push({ type: 'challenge', targetId: tid, label: `Challenge ${s.label}`, cost: 'W:2 Dr:1' });
      if (s.owner === player.id && game.canFortify(player.id, tid).ok)
        actions.push({ type: 'fortify', targetId: tid, label: `Fortify ${s.label}`, cost: 'W:1 Gr:1' });
    }
    if (s.type === SPACE_TYPES.DOG_PARK && game.canAlly(player.id, tid).ok) {
      actions.push({ type: 'ally', targetId: tid, label: `Ally at ${s.label}`, cost: 'W:1 Bd:1' });
    }
    if (s.type === SPACE_TYPES.WATER_SOURCE && game.canDrink(player.id).ok) {
      actions.push({ type: 'drink', targetId: tid, label: 'Drink', cost: 'Dr:1' });
    }

    if (actions.length > 0) result.push({ spaceId: tid, actions });
  }

  // PATH shortcut at current position
  const curSpace = board.getSpace(currentId);
  if (curSpace && curSpace.type === SPACE_TYPES.PATH && curSpace.pathExit && player.drive >= 1) {
    let entry = result.find(r => r.spaceId === currentId);
    if (!entry) { entry = { spaceId: currentId, actions: [] }; result.push(entry); }
    entry.actions.push({ type: 'shortcut', targetId: currentId, label: `Shortcut \u2192 ${curSpace.pathExit}`, cost: 'Dr:1' });
  }

  // Break alliance actions (attached to current position)
  for (const alliedId of player.allies) {
    if (game.canBreakAlliance(player.id, alliedId).ok) {
      const allyCfg = playerConfigs.find(c => c.id === alliedId);
      const allyName = allyCfg ? allyCfg.name : alliedId;
      let entry = result.find(r => r.spaceId === currentId);
      if (!entry) { entry = { spaceId: currentId, actions: [] }; result.push(entry); }
      entry.actions.push({ type: 'breakAlliance', targetId: alliedId, label: `Break alliance with ${allyName}`, cost: 'W:1 Sw:1' });
    }
  }

  return result;
}

// ═══════════════════════════════════════════════════════════════════════
//  GAME LOOP
// ═══════════════════════════════════════════════════════════════════════

async function runGame() {
  await delay(300);
  while (!game.gameOver) {
    game.startRound();
    addLogEntry(`=== Round ${game.turnNumber} ===`, 'round');
    updateSidebar();

    do {
      const player = game.getCurrentPlayer();
      const cfg = getConfig(player.id);
      addLogEntry(`--- ${cfg.name}'s turn ---`, 'system');
      updateSidebar();

      // Phase 1: Territory Income
      setPhase(`${cfg.name} — Income`);
      game.applyTerritoryIncome(player.id);
      flushEngineLog();
      updateSidebar();
      await delay(cfg.isAI ? 300 : 600);

      // Phase 2: Roll and Move
      setPhase(`${cfg.name} — Roll`);
      const d1 = Game.rollD6(), d2 = Game.rollD6();
      let maxSteps = d1 + d2;
      if (player.housebound) maxSteps = Math.floor(maxSteps / 2);
      showDice(d1, d2, maxSteps);
      addLogEntry(`${cfg.name} rolled ${d1}+${d2} = ${maxSteps}${player.housebound ? ' (housebound)' : ''}`, 'system');
      await delay(cfg.isAI ? 600 : 1200);
      hideDice();

      setPhase(`${cfg.name} — Move`);
      let path;
      if (cfg.isAI) {
        path = aiComputePath(player, maxSteps);
        // Animate AI movement step by step
        for (let i = 1; i < path.length; i++) {
          await delay(250);
          player.position = path[i]; // temp for visual
          updatePawns();
        }
        player.position = path[0]; // reset for movePlayer
      } else {
        path = await humanBuildPath(player, maxSteps);
      }

      const moveResult = game.movePlayer(player.id, path);
      flushEngineLog();
      updateOverlay();
      updatePawns();
      updateSidebar();

      // Process pass-through effects
      let passedHome = false;
      if (moveResult.success && moveResult.effects) {
        for (const eff of moveResult.effects) {
          if (eff.type === 'homeResupply') { passedHome = true; continue; }
          if (eff.type === 'dogPark') {
            game.applyDogPark(player.id);
            addLogEntry(`${cfg.name} passed Dog Park: +1 Bond`, 'action');
            updateSidebar();
          }
          if (eff.type === 'compulsoryBond') {
            const res = game.compulsoryBondJoin(player.id, eff.dogParkSpaceId);
            if (res.success) {
              addLogEntry(`${cfg.name} compulsory bond at ${eff.dogParkSpaceId}`, 'action');
              if (res.cleared && res.cleared.length > 0) {
                addLogEntry(`  Friendship sacrifice: cleared ${res.cleared.join(', ')}`, 'action');
              }
            }
            updateOverlay(); updateSidebar();
          }
          if (eff.type === 'pathEntry') {
            addLogEntry(`${cfg.name} at path entry (shortcut to ${eff.exitSpaceId} available)`, 'system');
          }
          if (eff.type === 'chanceCard') addLogEntry(`${cfg.name} passed Chance Spot (deck not implemented)`, 'system');
          if (eff.type === 'eventsCard') addLogEntry(`${cfg.name} passed Events (deck not implemented)`, 'system');
        }
      }

      // Phase 3: Action
      setPhase(`${cfg.name} — Action`);
      if (cfg.isAI) {
        await aiDoAction(player, cfg);
      } else {
        await humanDoAction(player, cfg);
      }
      clearControls();
      updateOverlay(); updatePawns(); updateSidebar();

      // Phase 4: Home Resupply
      if (passedHome) {
        game.applyHomeResupply(player.id);
        addLogEntry(`${cfg.name} resupplied at home`, 'action');
        updateSidebar();
      }

      // Phase 5: Maintenance
      setPhase(`${cfg.name} — Maintenance`);
      game.checkHousebound(player.id);
      flushEngineLog();
      const win = game.checkWinConditions();
      updateSidebar();
      if (win.gameOver) break;

      await delay(200);
    } while (game.advancePlayer());
  }

  showGameOver();
}

// ═══════════════════════════════════════════════════════════════════════
//  HUMAN INTERACTION
// ═══════════════════════════════════════════════════════════════════════

async function humanBuildPath(player, maxSteps) {
  const path = [player.position];
  let stepsLeft = maxSteps;
  let accDriveCost = 0;

  while (stepsLeft > 0) {
    const current = path[path.length - 1];
    const reachable = board.getNeighbors(current).filter(n =>
      !path.includes(n.space.id) && (accDriveCost + n.driveCost) <= player.drive
    );
    if (reachable.length === 0) break;

    highlightSpaces(reachable.map(n => n.space.id));
    setControls([
      { type: 'info', text: `Steps: ${stepsLeft} | Drive: ${player.drive - accDriveCost}` },
      { type: 'spacer' },
      { type: 'button', text: 'End Move', value: 'end', cls: 'primary' },
      path.length > 1 ? { type: 'button', text: 'Undo', value: 'undo', cls: 'warn' } : null,
    ].filter(Boolean));

    // Wait for either a space click or a control button
    const result = await Promise.race([
      waitForSpaceClick(reachable.map(n => n.space.id)).then(id => ({ type: 'space', id })),
      waitForControl().then(val => ({ type: 'ctrl', val })),
    ]);

    // Clear stale resolvers
    _resolveSpaceClick = null; _validSpaceIds = null; _resolveControlBtn = null;

    if (result.type === 'ctrl' && result.val === 'end') break;
    if (result.type === 'ctrl' && result.val === 'undo') {
      if (path.length > 1) {
        const removed = path.pop();
        const edge = board.getNeighbors(path[path.length - 1]).find(n => n.space.id === removed);
        if (edge) accDriveCost -= edge.driveCost;
        stepsLeft += 1;
        // Visual update
        player.position = path[path.length - 1];
        updatePawns();
      }
      continue;
    }
    if (result.type === 'space') {
      const edge = reachable.find(n => n.space.id === result.id);
      if (edge) {
        path.push(result.id);
        accDriveCost += edge.driveCost;
        stepsLeft -= 1;
        // Visual: move pawn as path builds
        player.position = result.id;
        updatePawns();
      }
    }
  }

  clearHighlights();
  clearControls();
  // Reset position so movePlayer can set it
  player.position = path[0];
  return path;
}

async function humanDoAction(player, cfg) {
  const actionable = getActionableSpaces(player);
  if (actionable.length === 0) {
    addLogEntry(`${cfg.name} has no available actions — passing.`, 'system');
    return;
  }

  // Show actionable spaces and controls
  const allIds = actionable.map(a => a.spaceId);
  highlightSpaces(allIds, 'highlight-action');

  while (true) {
    setControls([
      { type: 'info', text: 'Click a highlighted space or pass' },
      { type: 'spacer' },
      { type: 'button', text: 'Pass', value: 'pass', cls: '' },
    ]);

    const result = await Promise.race([
      waitForSpaceClick(allIds).then(id => ({ type: 'space', id })),
      waitForControl().then(val => ({ type: 'ctrl', val })),
    ]);
    _resolveSpaceClick = null; _validSpaceIds = null; _resolveControlBtn = null;

    if (result.type === 'ctrl' && result.val === 'pass') {
      addLogEntry(`${cfg.name} passes.`, 'system');
      break;
    }

    if (result.type === 'space') {
      const entry = actionable.find(a => a.spaceId === result.id);
      if (!entry) continue;

      // Show action buttons for this space
      const btns = entry.actions.map((a, i) => ({
        type: 'button', text: `${a.label} (${a.cost})`, value: String(i), cls: 'primary',
      }));
      btns.push({ type: 'spacer' });
      btns.push({ type: 'button', text: 'Back', value: 'back', cls: '' });
      setControls(btns);

      const actionResult = await waitForControl();
      _resolveControlBtn = null;

      if (actionResult === 'back') continue;

      const actionIdx = parseInt(actionResult);
      if (isNaN(actionIdx) || !entry.actions[actionIdx]) continue;

      const action = entry.actions[actionIdx];
      await executeAction(player, cfg, action);
      break;
    }
  }

  clearHighlights();
}

async function executeAction(player, cfg, action) {
  switch (action.type) {
    case 'claim': {
      game.claim(player.id, action.targetId);
      addLogEntry(`${cfg.name} claimed ${action.targetId}`, 'action');
      break;
    }
    case 'challenge': {
      await doChallenge(player, cfg, action.targetId);
      break;
    }
    case 'fortify': {
      game.fortify(player.id, action.targetId);
      addLogEntry(`${cfg.name} fortified ${action.targetId}`, 'action');
      break;
    }
    case 'ally': {
      game.ally(player.id, action.targetId);
      addLogEntry(`${cfg.name} initiated alliance at ${action.targetId}`, 'action');
      break;
    }
    case 'breakAlliance': {
      const allyCfg = getConfig(action.targetId);
      const allyName = allyCfg ? allyCfg.name : action.targetId;
      game.breakAlliance(player.id, action.targetId);
      addLogEntry(`${cfg.name} broke alliance with ${allyName}`, 'action');
      break;
    }
    case 'shortcut': {
      const res = game.takeShortcut(player.id, action.targetId);
      if (res.success) {
        addLogEntry(`${cfg.name} took shortcut \u2192 ${res.exitSpaceId}`, 'action');
      }
      break;
    }
    case 'drink': {
      const waterGain = 99; // tops up to archetype max
      game.drink(player.id, waterGain);
      addLogEntry(`${cfg.name} drank — water refilled`, 'action');
      break;
    }
  }
  flushEngineLog();
  updateOverlay(); updatePawns(); updateSidebar();
}

async function doChallenge(player, cfg, targetId) {
  const space = board.getSpace(targetId);
  const defId = space.owner;
  const defCfg = getConfig(defId);

  const payResult = game.payChallengeCost(player.id, targetId);
  if (!payResult.success) {
    addLogEntry(`Challenge failed: ${payResult.reason}`, 'challenge');
    return;
  }

  addLogEntry(`${cfg.name} challenges ${defCfg.name} at ${targetId}!`, 'challenge');
  updateSidebar();
  await delay(600);

  let result;
  do {
    const aRoll = Game.rollD6(), dRoll = Game.rollD6();
    showDice(aRoll, dRoll, null);
    await delay(900);
    hideDice();

    result = game.resolveChallenge(player.id, defId, targetId, aRoll, dRoll);
    addLogEntry(
      `  Attack ${result.attackRoll} \u2192 ${result.attackTotal}  vs  Defense ${result.defendRoll} \u2192 ${result.defendTotal}` +
      (result.fortifyBonus ? ` (+${result.fortifyBonus} fortify)` : '') +
      (result.clusterRule ? ' [cluster]' : ''),
      'challenge'
    );

    if (result.outcome === 'tie') {
      addLogEntry('  Tie! Re-rolling...', 'challenge');
      await delay(800);
    }
  } while (result.outcome === 'tie');

  if (result.outcome === 'attackerWins') {
    addLogEntry(`  ${cfg.name} wins!`, 'challenge');
    updateOverlay();

    // Re-claim choice
    const rc = game.canReClaim(player.id);
    if (rc.ok) {
      let useResource;
      if (cfg.isAI) {
        useResource = player.swagger >= 1 ? 'swagger' : (player.grit >= 1 ? 'grit' : null);
      } else {
        // Show re-claim choice
        const btns = [];
        if (player.swagger >= 1) btns.push({ type: 'button', text: 'Re-claim (Swagger)', value: 'swagger', cls: 'primary' });
        if (player.grit >= 1)    btns.push({ type: 'button', text: 'Re-claim (Grit)', value: 'grit', cls: 'primary' });
        btns.push({ type: 'spacer' });
        btns.push({ type: 'button', text: 'Decline', value: 'decline', cls: 'warn' });
        setControls(btns);
        useResource = await waitForControl();
        _resolveControlBtn = null;
        if (useResource === 'decline') useResource = null;
      }

      if (useResource) {
        game.reClaim(player.id, targetId, useResource);
        addLogEntry(`  ${cfg.name} re-claimed with ${useResource}`, 'action');
      } else {
        game.declineReClaim(targetId);
        addLogEntry(`  ${cfg.name} declined re-claim`, 'system');
      }
    } else {
      game.declineReClaim(targetId);
      addLogEntry(`  Cannot re-claim (no swagger or grit)`, 'system');
    }
  } else {
    addLogEntry(`  ${defCfg.name} defends!`, 'challenge');
  }

  flushEngineLog();
  updateOverlay(); updatePawns(); updateSidebar();
}

// ═══════════════════════════════════════════════════════════════════════
//  AI PLAYER (strategic evaluation)
// ═══════════════════════════════════════════════════════════════════════

// ── 1. Per-archetype action weight tables ──

function getArchetypeWeights(archetypeKey) {
  const tables = {
    bruiser:  { claim: 2.0, challenge: 1.2, fortify: 0.6, ally: 0.3, drink: 1.0, breakAlliance: 0.4 },
    scrapper: { claim: 1.2, challenge: 2.0, fortify: 0.4, ally: 0.5, drink: 0.8, breakAlliance: 0.6 },
    diplomat: { claim: 1.0, challenge: 0.5, fortify: 0.8, ally: 2.0, drink: 1.0, breakAlliance: 0.8 },
    yapper:   { claim: 0.8, challenge: 0.8, fortify: 2.0, ally: 0.6, drink: 1.0, breakAlliance: 0.3 },
  };
  return tables[archetypeKey] || tables.bruiser;
}

// ── 2. State assessment helpers ──

function waterUrgency(player) {
  const arch = ARCHETYPES[player.archetype];
  const ratio = player.water / arch.water;
  if (ratio >= 0.6) return 0.0;
  if (ratio >= 0.3) return 1.0;
  if (ratio > 0)    return 2.0;
  return 3.0;
}

function isDesperation(player) {
  return board.getTerritoriesOwnedBy(player.id).length === 0;
}

function getLeader() {
  for (const p of game.players) {
    if (board.getTerritoriesOwnedBy(p.id).length >= 7) return p;
  }
  return null;
}

// ── 3. BFS pathfinding ──

function bfsReachable(player, maxSteps) {
  const reachable = new Map();
  // queue entries: [spaceId, stepsUsed, driveCost, parentId]
  const queue = [[player.position, 0, 0, null]];
  reachable.set(player.position, { steps: 0, driveCost: 0, parent: null });

  while (queue.length > 0) {
    const [curId, steps, drCost, parentId] = queue.shift();
    if (steps >= maxSteps) continue;

    for (const n of board.getNeighbors(curId)) {
      const nId = n.space.id;
      const newDrive = drCost + n.driveCost;
      if (newDrive > player.drive) continue;
      const newSteps = steps + 1;
      const existing = reachable.get(nId);
      // Accept if unvisited, or if new path is cheaper (fewer steps, then less drive)
      if (!existing || newSteps < existing.steps || (newSteps === existing.steps && newDrive < existing.driveCost)) {
        reachable.set(nId, { steps: newSteps, driveCost: newDrive, parent: curId });
        queue.push([nId, newSteps, newDrive, curId]);
      }
    }
  }
  return reachable;
}

function reconstructPath(reachable, targetId) {
  const path = [];
  let cur = targetId;
  while (cur !== null) {
    path.unshift(cur);
    const info = reachable.get(cur);
    if (!info) break;
    cur = info.parent;
  }
  return path;
}

// ── 4. Board analysis helpers ──

function nearestDistance(fromId, spaceType) {
  const visited = new Set([fromId]);
  const queue = [[fromId, 0]];
  while (queue.length > 0) {
    const [cur, dist] = queue.shift();
    const s = board.getSpace(cur);
    if (s && s.type === spaceType && dist > 0) return dist;
    for (const n of board.getNeighbors(cur)) {
      if (!visited.has(n.space.id)) {
        visited.add(n.space.id);
        queue.push([n.space.id, dist + 1]);
      }
    }
  }
  return Infinity;
}

function distanceToSpace(fromId, targetId) {
  if (fromId === targetId) return 0;
  const visited = new Set([fromId]);
  const queue = [[fromId, 0]];
  while (queue.length > 0) {
    const [cur, dist] = queue.shift();
    for (const n of board.getNeighbors(cur)) {
      if (n.space.id === targetId) return dist + 1;
      if (!visited.has(n.space.id)) {
        visited.add(n.space.id);
        queue.push([n.space.id, dist + 1]);
      }
    }
  }
  return Infinity;
}

function clusterProximityScore(playerId, spaceId) {
  const neighbors = board.getNeighbors(spaceId);
  let ownedAdjacentCount = 0;
  let adjacentInPair = false;
  let completesCluster = false;

  for (const n of neighbors) {
    if (n.space.type === SPACE_TYPES.TERRITORY && n.space.owner === playerId) {
      ownedAdjacentCount++;
      // Check if this adjacent territory is already in a pair (part of group of 2+)
      for (const nn of board.getNeighbors(n.space.id)) {
        if (nn.space.id !== spaceId && nn.space.type === SPACE_TYPES.TERRITORY && nn.space.owner === playerId) {
          adjacentInPair = true;
        }
      }
    }
  }

  if (ownedAdjacentCount >= 2) completesCluster = true;
  if (ownedAdjacentCount >= 1 && adjacentInPair) completesCluster = true;

  if (completesCluster) return 5.0;
  if (ownedAdjacentCount >= 2) return 2.5;
  if (ownedAdjacentCount === 1) return 1.0;
  return 0.0;
}

function challengeWinProbability(attackerId, territoryId) {
  const att = game.getPlayer(attackerId);
  const space = board.getSpace(territoryId);
  if (!space || !space.owner) return 0;
  const def = game.getPlayer(space.owner);
  if (!def) return 0;

  const fortBonus = space.fortifyTokens;
  const diplomatPenalty = att.archetype === 'diplomat' ? 1 : 0;
  const gritPenalty = att.grit > game.config.gritPenaltyThreshold
    ? att.grit - game.config.gritPenaltyThreshold : 0;
  // Yapper adds 1 grit but doesn't affect current roll
  const cluster = board.isInCluster(territoryId, space.owner);

  let wins = 0;
  for (let aRoll = 1; aRoll <= 6; aRoll++) {
    for (let dRoll = 1; dRoll <= 6; dRoll++) {
      const aT = aRoll - diplomatPenalty - gritPenalty;
      const dT = dRoll + fortBonus;
      if (aT > dT) {
        wins++;
      } else if (aT === dT && !cluster) {
        // Ties re-roll — count as 0.5 win (recursive expectation)
        wins += 0.5;
      }
    }
  }
  return wins / 36;
}

function clusterDisruptionValue(attackerId, territoryId) {
  const space = board.getSpace(territoryId);
  if (!space || !space.owner) return 0;
  const defId = space.owner;

  // Check what groups the defender has that include this territory
  const groups = board.getConnectedTerritoryGroups(defId);
  for (const g of groups) {
    if (g.includes(territoryId)) {
      if (g.length >= 3) return 4.0;  // Breaking a cluster
      if (g.length === 2) return 2.0;  // Breaking a pair
      return 0.5;
    }
  }
  return 0;
}

function fortifyWorthiness(playerId, territoryId) {
  const space = board.getSpace(territoryId);
  if (!space || space.owner !== playerId) return -Infinity;

  // Check if in a cluster or adjacent to owned territories
  const neighbors = board.getNeighbors(territoryId);
  let ownedAdjacentCount = 0;
  let isHomeAdjacent = false;

  for (const n of neighbors) {
    if (n.space.type === SPACE_TYPES.TERRITORY && n.space.owner === playerId) ownedAdjacentCount++;
    if (n.space.type === SPACE_TYPES.HOME && n.space.playerColour === game.getPlayer(playerId).colour) isHomeAdjacent = true;
  }

  // Hard block: isolated territories not worth fortifying
  if (ownedAdjacentCount === 0 && !isHomeAdjacent) return -Infinity;

  let score = 1.0;
  if (board.isInCluster(territoryId, playerId)) score += 3.0;
  else if (ownedAdjacentCount >= 1) score += 1.5;
  if (isHomeAdjacent) score += 1.0;
  // More valuable to fortify when tokens are low
  score += (3 - space.fortifyTokens) * 0.5;
  return score;
}

function allianceValue(player, dogParkSpaceId) {
  let score = 1.5;
  if (player.archetype === 'diplomat') score += 1.5;

  // Prefer allying when there's a pending alliance that could catch opponents
  if (game.pendingAlliances.has(dogParkSpaceId)) {
    score -= 1.0; // Already pending — initiating here is redundant
  }

  // Value higher if opponents have more territories near us
  const homeSpace = board.getHomeSpace(player.id, game.players);
  if (homeSpace) {
    const homeNeighbors = board.getHomeNeighbourhood(player.id, game.players);
    const threatCount = homeNeighbors.filter(t => t.owner && t.owner !== player.id).length;
    score += threatCount * 0.5;
  }

  return score;
}

function breakAllianceValue(player, alliedPlayerId) {
  const leader = getLeader();
  if (leader && leader.id === alliedPlayerId) return 3.0;

  const allyTerritories = board.getTerritoriesOwnedBy(alliedPlayerId).length;
  const myTerritories = board.getTerritoriesOwnedBy(player.id).length;

  // Break if ally is significantly ahead
  if (allyTerritories >= myTerritories + 3) return 2.0;
  return 0.3;
}

// ── 5. Destination scoring ──

function scoreDestination(player, destId, reachableInfo) {
  const arch = ARCHETYPES[player.archetype];
  const weights = getArchetypeWeights(player.archetype);
  const space = board.getSpace(destId);
  if (!space) return -Infinity;

  const desperate = isDesperation(player);
  const urgency = waterUrgency(player);
  const leader = getLeader();
  let score = 0;

  // Hard rule: water=1 + not at home → penalize moving away from home or water
  if (player.water <= 1) {
    const homeSpace = board.getHomeSpace(player.id, game.players);
    if (homeSpace) {
      const homeDist = distanceToSpace(destId, homeSpace.id);
      const curHomeDist = distanceToSpace(player.position, homeSpace.id);
      const waterDist = nearestDistance(destId, SPACE_TYPES.WATER_SOURCE);
      if (homeDist > curHomeDist && waterDist > 2) {
        return -Infinity;
      }
    }
  }

  // Evaluate based on space type and surroundings
  switch (space.type) {
    case SPACE_TYPES.TERRITORY: {
      if (space.owner === null) {
        // Unclaimed territory
        const clusterBonus = clusterProximityScore(player.id, destId);
        if (desperate) {
          score += 10.0;
        } else {
          score += (3.0 + clusterBonus) * weights.claim;
        }
      } else if (space.owner !== player.id) {
        // Opponent territory — potential challenge
        const winProb = challengeWinProbability(player.id, destId);
        const disruption = clusterDisruptionValue(player.id, destId);
        score += winProb * (3.0 + disruption * 2.0) * weights.challenge;
        if (leader && space.owner === leader.id) score *= 1.8;
        // Don't encourage challenges when we can't afford them
        if (player.water < 2 || player.drive < 1) score *= 0.1;
      } else {
        // Own territory — potential fortify
        const worth = fortifyWorthiness(player.id, destId);
        if (worth > -Infinity) {
          score += worth * weights.fortify * 0.5;
        }
      }
      break;
    }
    case SPACE_TYPES.WATER_SOURCE: {
      score += urgency * 2.5 * weights.drink;
      if (player.water <= 1) score += 5.0;
      break;
    }
    case SPACE_TYPES.HOME: {
      if (space.playerColour === player.colour) {
        // Own home — resupply value
        score += urgency * 2.0;
        // General resource deficit
        const deficit = (arch.water - player.water) + (arch.swagger - player.swagger) +
                        (arch.drive - player.drive) + (arch.bond - player.bond);
        score += Math.max(0, deficit) * 0.3;
        if (player.water <= 1) score += 4.0;
      }
      break;
    }
    case SPACE_TYPES.DOG_PARK: {
      score += allianceValue(player, destId) * weights.ally * 0.5;
      break;
    }
    case SPACE_TYPES.CHANCE_SPOT: {
      score += 1.0; // Mild bonus for chance spots
      break;
    }
    case SPACE_TYPES.PATH: {
      score += 0.5; // Shortcuts have repositioning value
      break;
    }
    default: break;
  }

  // Also evaluate neighbors of destination (what actions become available there)
  const destNeighbors = board.getNeighbors(destId);
  for (const n of destNeighbors) {
    if (n.space.type === SPACE_TYPES.TERRITORY && n.space.owner === null) {
      const clusterBonus = clusterProximityScore(player.id, n.space.id);
      const neighborVal = desperate ? 5.0 : (1.5 + clusterBonus * 0.5) * weights.claim;
      score += neighborVal * 0.3; // Discounted since it's adjacent, not at dest
    }
    if (n.space.type === SPACE_TYPES.WATER_SOURCE && urgency > 0) {
      score += urgency * 0.5;
    }
  }

  // Dead-end penalty
  if (destNeighbors.length <= 1) score -= 2.0;

  // Distance penalty
  score -= reachableInfo.steps * 0.1;

  return score;
}

// ── 6. Action scoring ──

function scoreAction(player, action) {
  const weights = getArchetypeWeights(player.archetype);
  const desperate = isDesperation(player);
  const leader = getLeader();
  let score = 0;

  switch (action.type) {
    case 'claim': {
      const clusterBonus = clusterProximityScore(player.id, action.targetId);
      score = (3.0 + clusterBonus) * weights.claim;
      if (desperate) score += 10.0;
      // Simulate swagger income delta: check if claiming adds to connected groups
      const groups = board.getConnectedTerritoryGroups(player.id);
      const currentIncome = groups.reduce((t, g) => t + Math.floor(g.length / game.config.swaggerPerTerritories), 0);
      // Temporarily claim to check new income
      const space = board.getSpace(action.targetId);
      space.owner = player.id;
      const newGroups = board.getConnectedTerritoryGroups(player.id);
      const newIncome = newGroups.reduce((t, g) => t + Math.floor(g.length / game.config.swaggerPerTerritories), 0);
      space.owner = null; // Restore
      const incomeDelta = newIncome - currentIncome;
      score += incomeDelta * 2.0;
      break;
    }
    case 'challenge': {
      const winProb = challengeWinProbability(player.id, action.targetId);
      const disruption = clusterDisruptionValue(player.id, action.targetId);
      score = winProb * (3.0 + disruption * 2.0) * weights.challenge;
      // Leader targeting
      const space = board.getSpace(action.targetId);
      if (leader && space && space.owner === leader.id) score *= 2.0;
      // Grit threshold penalty
      if (player.grit >= game.config.gritPenaltyThreshold) score *= 0.5;
      // Yapper caution
      if (space && space.owner) {
        const def = game.getPlayer(space.owner);
        if (def && def.archetype === 'yapper') score *= 0.7;
      }
      break;
    }
    case 'fortify': {
      const worth = fortifyWorthiness(player.id, action.targetId);
      score = worth * weights.fortify;
      break;
    }
    case 'ally': {
      score = allianceValue(player, action.targetId) * weights.ally;
      break;
    }
    case 'breakAlliance': {
      score = breakAllianceValue(player, action.targetId) * weights.breakAlliance;
      break;
    }
    case 'drink': {
      const urgency = waterUrgency(player);
      score = urgency * 2.0 * weights.drink;
      if (player.water <= 1) score += 5.0;
      break;
    }
    case 'shortcut': {
      score = 1.5;
      break;
    }
  }

  // Resource conservation: actions that drop water below 2 get penalty
  const waterCosts = { claim: 2, challenge: 2, fortify: 1, ally: 1, breakAlliance: 1, drink: 0, shortcut: 0 };
  const waterAfter = player.water - (waterCosts[action.type] || 0);
  if (waterAfter < 2 && waterAfter >= 0) score *= 0.6;

  return score;
}

// ── 7. Hard rule enforcement ──

function applyHardRules(player, actionsWithScores) {
  let mustAct = false;

  for (const item of actionsWithScores) {
    // Never fortify isolated territory
    if (item.action.type === 'fortify') {
      const worth = fortifyWorthiness(player.id, item.action.targetId);
      if (worth === -Infinity) item.score = -Infinity;
    }

    // Never challenge allied player
    if (item.action.type === 'challenge') {
      const space = board.getSpace(item.action.targetId);
      if (space && space.owner && player.allies.includes(space.owner)) {
        item.score = -Infinity;
      }
    }

    // If a claim is available and affordable, AI must act
    if (item.action.type === 'claim' && item.score > -Infinity) {
      mustAct = true;
    }
  }

  return mustAct;
}

// ── 8. AI path computation (BFS + scored destinations) ──

function aiComputePath(player, maxSteps) {
  const reachable = bfsReachable(player, maxSteps);

  // Score every reachable destination
  let bestScore = -Infinity;
  let bestDest = player.position;

  for (const [destId, info] of reachable) {
    if (destId === player.position && reachable.size > 1) continue; // Prefer moving
    const score = scoreDestination(player, destId, info);
    if (score > bestScore) {
      bestScore = score;
      bestDest = destId;
    }
  }

  // Desperation override: if no destination scored well but we're desperate, pick any unclaimed territory
  if (bestScore <= 0 && isDesperation(player)) {
    for (const [destId, info] of reachable) {
      const s = board.getSpace(destId);
      if (s && s.type === SPACE_TYPES.TERRITORY && s.owner === null) {
        bestDest = destId;
        break;
      }
      // Also check neighbors of reachable spaces
      for (const n of board.getNeighbors(destId)) {
        if (n.space.type === SPACE_TYPES.TERRITORY && n.space.owner === null && reachable.has(destId)) {
          bestDest = destId;
          break;
        }
      }
    }
  }

  // Stay put if nothing scores positively (and not desperate)
  if (bestScore <= 0 && !isDesperation(player)) {
    return [player.position];
  }

  const path = reconstructPath(reachable, bestDest);
  // Ensure path starts at player position
  if (path.length === 0 || path[0] !== player.position) return [player.position];
  return path;
}

// ── 9. AI action selection (scored + hard rules) ──

async function aiDoAction(player, cfg) {
  await delay(400);
  const actionable = getActionableSpaces(player);
  if (actionable.length === 0) {
    addLogEntry(`${cfg.name} (AI) passes.`, 'system');
    return;
  }

  // Score every available action
  const allActions = actionable.flatMap(a => a.actions);
  if (allActions.length === 0) {
    addLogEntry(`${cfg.name} (AI) passes.`, 'system');
    return;
  }

  const scored = allActions.map(action => ({
    action,
    score: scoreAction(player, action),
  }));

  // Apply hard rules
  const mustAct = applyHardRules(player, scored);

  // Sort by score descending
  scored.sort((a, b) => b.score - a.score);

  // If mustAct (claim available), force the best claim
  if (mustAct) {
    const bestClaim = scored.find(s => s.action.type === 'claim' && s.score > -Infinity);
    if (bestClaim) {
      await executeAction(player, cfg, bestClaim.action);
      return;
    }
  }

  // Pick the best scoring action, pass if score <= 0
  const best = scored[0];
  if (!best || best.score <= 0) {
    addLogEntry(`${cfg.name} (AI) passes.`, 'system');
    return;
  }

  await executeAction(player, cfg, best.action);
}

// ═══════════════════════════════════════════════════════════════════════
//  GAME OVER
// ═══════════════════════════════════════════════════════════════════════

function showGameOver() {
  setPhase('Game Over');
  const winCfg = getConfig(game.winner);
  document.getElementById('go-title').textContent = `${winCfg.name} Wins!`;

  // Build ranking
  const ranked = [...game.players].sort((a, b) =>
    board.getTerritoriesOwnedBy(b.id).length - board.getTerritoriesOwnedBy(a.id).length
  );
  const detail = ranked.map((p, i) => {
    const c = getConfig(p.id);
    const terr = board.getTerritoriesOwnedBy(p.id).length;
    return `${i + 1}. ${c.name} (${ARCHETYPES[c.archetype].name}) \u2014 ${terr} territories`;
  }).join('\n');
  document.getElementById('go-detail').textContent = detail;
  document.getElementById('go-detail').style.whiteSpace = 'pre-line';
  document.getElementById('game-over').classList.add('visible');
}

function exportLog() {
  const lines = [];
  // Header
  lines.push('Uri-Nation Game Log');
  lines.push('='.repeat(40));
  lines.push(`Date: ${new Date().toISOString()}`);
  lines.push(`Rounds: ${game.turnNumber}`);
  lines.push(`Winner: ${getConfig(game.winner)?.name || game.winner}`);
  lines.push('');
  // Players
  lines.push('Players:');
  for (const p of game.players) {
    const c = getConfig(p.id);
    const terr = board.getTerritoriesOwnedBy(p.id).length;
    lines.push(`  ${c.name} (${ARCHETYPES[c.archetype].name}) — ${terr} territories, W:${p.water} Sw:${p.swagger} Dr:${p.drive} Gr:${p.grit} Bd:${p.bond}`);
  }
  lines.push('');
  // Full engine log
  lines.push('Game Log:');
  lines.push('-'.repeat(40));
  for (const entry of game.log) {
    const prefix = entry.player ? `[${getConfig(entry.player)?.name || entry.player}] ` : '';
    lines.push(`R${entry.turn} ${prefix}${entry.message}`);
  }

  const blob = new Blob([lines.join('\n')], { type: 'text/plain' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `game-log-${new Date().toISOString().slice(0,10)}.txt`;
  a.click();
  URL.revokeObjectURL(a.href);
}

// ═══════════════════════════════════════════════════════════════════════
//  MISC HELPERS
// ═══════════════════════════════════════════════════════════════════════

function getConfig(playerId) {
  return playerConfigs.find(c => c.id === playerId);
}

let lastLogIdx = 0;
function flushEngineLog() {
  while (lastLogIdx < game.log.length) {
    const entry = game.log[lastLogIdx];
    const prefix = entry.player ? `[${getConfig(entry.player)?.name || entry.player}] ` : '';
    lastLogIdx++;
  }
}

// ═══════════════════════════════════════════════════════════════════════
//  INIT
// ═══════════════════════════════════════════════════════════════════════

document.addEventListener('DOMContentLoaded', () => {
  initSetup();
  buildPlayerConfigRows(2);
});
</script>
</body>
</html>
